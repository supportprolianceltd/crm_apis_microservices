// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [postgis]
}

// ─────────────────────────────────────────────
// CORE MODELS
// ─────────────────────────────────────────────

model ExternalRequest {
  id                 String                                 @id // Custom generated IDs
  tenantId           String
  subject            String
  content            String                                 @db.Text
  requestorEmail     String
  requestorName      String?
  requestorPhone     String?
  address            String
  postcode           String
  location           Unsupported("geography(POINT, 4326)")?
  latitude           Float?
  longitude          Float?
  urgency            RequestUrgency                         @default(MEDIUM)
  status             RequestStatus                          @default(PENDING)
  requirements       String?                                @db.Text
  requiredSkills     String[]                               @default([])
  estimatedDuration  Int?
  scheduledStartTime DateTime?
  scheduledEndTime   DateTime?
  recurrencePattern  String?
  notes              String?                                @db.Text
  emailMessageId     String?
  emailThreadId      String?
  requestTypes       String?

  // Approval fields
  approvedBy          String?
  approvedAt          DateTime?
  approvedByEmail     String?   @map("approved_by_email")
  approvedByFirstName String?   @map("approved_by_first_name")
  approvedByLastName  String?   @map("approved_by_last_name")

  // Creation tracking
  createdBy          String? @map("created_by")
  createdByEmail     String? @map("created_by_email")
  createdByFirstName String? @map("created_by_first_name")
  createdByLastName  String? @map("created_by_last_name")

  // UPDATE TRACKING (ADD THESE FIELDS)
  updatedBy          String? @map("updated_by")
  updatedByEmail     String? @map("updated_by_email")
  updatedByFirstName String? @map("updated_by_first_name")
  updatedByLastName  String? @map("updated_by_last_name")

  sendToRostering Boolean
  clusterId       String?
  cluster         Cluster?            @relation(fields: [clusterId], references: [id])
  matches         RequestCarerMatch[]
  visits          Visit[]

  availabilityRequirements Json?

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  processedAt DateTime?

  @@index([tenantId])
  @@index([status])
  @@index([urgency])
  @@index([postcode])
  @@index([createdAt])
  @@index([scheduledStartTime])
  @@index([clusterId])
  @@index([createdBy])
  @@index([approvedBy])
  @@index([updatedBy])
  @@index([id(ops: raw("varchar_pattern_ops"))])
  @@map("external_requests")
}

model Visit {
  id                String           @id // Remove @default(cuid()), we'll generate custom IDs
  tenantId          String
  externalRequestId String?          @map("external_request_id") // Add ? to make it optional
  externalRequest   ExternalRequest? @relation(fields: [externalRequestId], references: [id], onDelete: Cascade) // Also make relation optional

  // Core visit details
  subject        String
  content        String                                 @db.Text
  requestorEmail String
  requestorName  String?
  requestorPhone String?
  address        String
  postcode       String
  location       Unsupported("geography(POINT, 4326)")?
  latitude       Float?
  longitude      Float?

  // Scheduling
  scheduledStartTime DateTime
  scheduledEndTime   DateTime?
  estimatedDuration  Int?
  recurrencePattern  String?

  // Requirements
  urgency        RequestUrgency @default(MEDIUM)
  requirements   String?        @db.Text
  requiredSkills String[]       @default([])
  notes          String?        @db.Text

  // Availability requirements (optional)
  availabilityRequirements Json?

  // Status and lifecycle
  status             VisitStatus      @default(SCHEDULED)
  isActive           Boolean          @default(true)
  assignmentStatus   AssignmentStatus @default(PENDING)
  assignedAt         DateTime?
  travelFromPrevious Int?
  complianceChecks   Json?

  // Assigned carer information (denormalized for performance)
  assignedCarerId           String?
  assignedCarerFirstName    String?
  assignedCarerLastName     String?
  assignedCarerEmail        String?
  assignedCarerSkills       String[] @default([])
  assignedCarerAvailability Json?

  clusterId String?
  cluster   Cluster? @relation(fields: [clusterId], references: [id])

  // Tracking
  createdBy      String?  @map("created_by")
  createdByEmail String?  @map("created_by_email")
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  assignments      Assignment[]
  timesheetEntries TimesheetEntry[]
  invoiceLineItems InvoiceLineItem[]
  visitCheckIns    VisitCheckIn[]
  visitCheckOuts   VisitCheckOut[]
  latenessAlerts   LatenessAlert[]
  incidents        Incident[]

  @@index([tenantId])
  @@index([externalRequestId])
  @@index([status])
  @@index([scheduledStartTime])
  @@index([clusterId])
  @@index([createdBy])
  @@map("visits")
}

model Carer {
  id        String                                 @id @default(cuid())
  tenantId  String
  email     String
  firstName String
  lastName  String
  phone     String?
  address   String
  postcode  String
  country   String?
  location  Unsupported("geography(POINT, 4326)")?
  latitude  Float?
  longitude Float?

  isActive          Boolean  @default(true)
  maxTravelDistance Int      @default(10000)
  availabilityHours Json?
  skills            String[] @default([])
  languages         String[] @default([])

  qualification String?
  experience    Int?
  hourlyRate    Float?
  authUserId    String?

  clusterId String?
  cluster   Cluster? @relation(fields: [clusterId], references: [id])

  matches              RequestCarerMatch[]
  timesheets           Timesheet[]
  payslips             Payslip[]
  publishedAssignments PublishedAssignment[]
  assignments          Assignment[]          @relation("CarerAssignments")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, email])
  @@index([tenantId])
  @@index([isActive])
  @@index([postcode])
  @@index([skills])
  @@index([clusterId])
  @@map("carers")
}

model ClusterAssignment {
  id         String   @id @default(cuid())
  carerId    String // Reference to auth service carer ID
  clusterId  String
  tenantId   String
  assignedAt DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relationships
  cluster Cluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@unique([carerId, tenantId]) // One carer per tenant
  @@index([carerId])
  @@index([clusterId])
  @@index([tenantId])
  @@index([assignedAt])
}

model RequestCarerMatch {
  id       String @id @default(cuid())
  tenantId String

  requestId String
  request   ExternalRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
  carerId   String
  carer     Carer           @relation(fields: [carerId], references: [id], onDelete: Cascade)

  distance   Float
  matchScore Float
  status     MatchStatus @default(PENDING)

  respondedAt      DateTime?
  response         MatchResponse?
  responseNotes    String?
  notificationSent Boolean        @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([requestId, carerId])
  @@index([tenantId])
  @@index([status])
  @@index([createdAt])
  @@index([distance])
  @@map("request_carer_matches")
}

model EmailProcessingLog {
  id           String           @id @default(cuid())
  tenantId     String
  messageId    String
  subject      String
  fromAddress  String
  processedAt  DateTime         @default(now())
  status       ProcessingStatus
  errorMessage String?
  requestId    String?

  @@unique([tenantId, messageId])
  @@index([tenantId])
  @@index([processedAt])
  @@index([status])
  @@map("email_processing_logs")
}

model GeocodingCache {
  id         String                                @id @default(cuid())
  address    String                                @unique
  postcode   String?
  latitude   Float
  longitude  Float
  location   Unsupported("geography(POINT, 4326)")
  confidence Float?
  source     String                                @default("nominatim")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([postcode])
  @@map("geocoding_cache")
}

model TenantEmailConfig {
  id           String  @id @default(cuid())
  tenantId     String  @unique
  imapHost     String
  imapPort     Int     @default(993)
  imapUser     String
  imapPassword String
  imapTls      Boolean @default(true)

  isActive     Boolean   @default(true)
  pollInterval Int       @default(300)
  lastChecked  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("tenant_email_configs")
}

model Cluster {
  location    String?
  id          String  @id @default(cuid())
  tenantId    String
  name        String
  description String?
  postcode    String?

  regionCenter Unsupported("geography(POINT, 4326)")?
  latitude     Float?
  longitude    Float?
  radiusMeters Int                                    @default(5000)

  activeRequestCount Int @default(0)
  totalRequestCount  Int @default(0)
  activeCarerCount   Int @default(0)
  totalCarerCount    Int @default(0)

  averageMatchTime Int?
  lastActivityAt   DateTime?

  // Relationships
  requests                   ExternalRequest[]
  carers                     Carer[]
  clusterAssignments         ClusterAssignment[]
  visits                     Visit[]
  clientClusterDistances     ClientClusterDistance[]
  clusterAgreedCareSchedules ClusterAgreedCareSchedule[]
  clusterClients             ClusterClient[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId])
  @@index([latitude, longitude])
  @@index([tenantId, activeRequestCount])
  @@index([tenantId, activeCarerCount])
  @@map("clusters")
}

// ─────────────────────────────────────────────
// CARE PLAN MODELS
// ─────────────────────────────────────────────

model CarePlan {
  id          String         @id @default(cuid())
  tenantId    String
  clientId    String
  title       String
  description String?
  startDate   DateTime?
  endDate     DateTime?
  status      CarePlanStatus @default(ACTIVE)

  carers               CarePlanCarer[]
  riskAssessment       RiskAssessment?
  personalCare         PersonalCare?
  everydayActivityPlan EverydayActivityPlan?
  fallsAndMobility     FallsAndMobility?
  medicalInfo          MedicalInformation?
  psychologicalInfo    PsychologicalInformation?
  foodHydration        FoodNutritionHydration?
  routine              RoutinePreference?
  cultureValues        CultureValues?
  bodyMap              BodyMap?
  movingHandling       MovingHandling?
  legalRequirement     LegalRequirement?
  careRequirements     CareRequirements?

  tasks Task[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId])
  @@index([tenantId, clientId])
}

model CarePlanCarer {
  id         String @id @default(cuid())
  tenantId   String
  carePlanId String
  carerId    String

  carePlan CarePlan @relation(fields: [carePlanId], references: [id], onDelete: Cascade)

  @@unique([tenantId, carePlanId, carerId])
  @@index([tenantId])
}

model RiskAssessment {
  id                        String   @id @default(cuid())
  tenantId                  String
  carePlanId                String   @unique
  primarySupportNeed        String?
  riskFactorsAndAlerts      String[] @default([])
  details                   String?
  areasRequiringSupport     String[] @default([])
  homeLayout                String?
  safetyFeaturesPresent     String[] @default([])
  hazards                   String[] @default([])
  accessibilityNeeds        String[] @default([])
  loneWorkerConsideration   Boolean?
  riskAssessmentAndTraining String?

  carePlan CarePlan @relation(fields: [carePlanId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([carePlanId])
}

model PersonalCare {
  id                      String             @id @default(cuid())
  tenantId                String
  carePlanId              String             @unique
  bathingAndShowering     BathingAssistance?
  oralHygiene             String?
  maintainThemselves      String?
  dressThemselves         String?
  groomingNeeds           String[]           @default([])
  toiletUsage             String?
  bowelControl            String?
  bladderControl          String?
  toiletingSupport        String?
  additionalNotes         String?            @db.Text
  continenceCare          String?
  mobilityAssistance      String?
  preferredLanguage       String?
  communicationStyleNeeds String?

  carePlan CarePlan @relation(fields: [carePlanId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([carePlanId])
}

model EverydayActivityPlan {
  id                            String  @id @default(cuid())
  tenantId                      String
  carePlanId                    String  @unique
  canTheyShop                   String?
  canTheyCall                   String?
  canTheyWash                   String?
  additionalNotes               String? @db.Text
  communityAccessNeeds          String?
  ExerciseandMobilityActivities String?

  carePlan CarePlan @relation(fields: [carePlanId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([carePlanId])
}

model FallsAndMobility {
  id                      String           @id @default(cuid())
  tenantId                String
  carePlanId              String           @unique
  fallenBefore            Boolean          @default(false)
  timesFallen             Int?
  mobilityLevel           MobilityLevel?
  mobilitySupport         MobilitySupport?
  otherMobilitySupport    String?
  activeAsTheyLikeToBe    String?
  canTransfer             String?
  canuseStairs            String?
  canTravelAlone          String?
  mobilityAdditionalNotes String?          @db.Text
  visionStatus            String?
  speechStatus            String?
  hearingStatus           String?
  sensoryAdditionalNotes  String?          @db.Text

  carePlan CarePlan @relation(fields: [carePlanId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([carePlanId])
}

model MedicalInformation {
  id                            String  @id @default(cuid())
  tenantId                      String
  carePlanId                    String  @unique
  primaryDiagnosis              String?
  primaryAdditionalNotes        String? @db.Text
  secondaryDiagnoses            String?
  secondaryAdditionalNotes      String? @db.Text
  pastMedicalHistory            String?
  medicalSupport                Boolean @default(false)
  breathingDifficulty           Boolean @default(false)
  breathingSupportNeed          String?
  useAirWayManagementEquipment  Boolean @default(false)
  specifyAirwayEquipment        String?
  airwayEquipmentRisk           String?
  airWayEquipmentMitigationPlan String?
  haveSkinPressureSores         Boolean @default(false)
  skinPressureConcerningIssues  Boolean @default(false)
  skinAdditionalInformation     String? @db.Text
  currentHealthStatus           String?

  raisedSafeGuardingIssue           Boolean         @default(false)
  safeGuardingAdditionalInformation String?         @db.Text
  medications                       Medication[]
  primaryDoctor                     String?
  supportContactPhone               String?
  specialistContact                 String?
  HospitalContact                   String?
  EmergencyCareNotes                String?
  medicalReportUpload               String?
  knownAllergies                    Boolean         @default(false)
  clientAllergies                   ClientAllergy[]

  carePlan CarePlan @relation(fields: [carePlanId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([carePlanId])
}

model ClientAllergy {
  id                         String   @id @default(cuid())
  tenantId                   String
  medicalInfoId              String
  allergy                    String
  severity                   String
  allergyDetails             String
  allergyMedicationFrequency String
  allergyMedicationName      String
  allergyMedicationDosage    String
  Appointments               DateTime
  knownTrigger               String

  medicalInfo MedicalInformation @relation(fields: [medicalInfoId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([medicalInfoId])
}

model Medication {
  id            String @id @default(cuid())
  tenantId      String
  medicalInfoId String

  drugName  String
  dosage    String
  frequency String

  medicalInfo MedicalInformation @relation(fields: [medicalInfoId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([medicalInfoId])
}

model PsychologicalInformation {
  id                          String  @id @default(cuid())
  tenantId                    String
  carePlanId                  String  @unique
  healthLevelSatisfaction     String?
  healthMotivationalLevel     String?
  sleepMood                   String?
  specifySleepMood            String?
  sleepStatus                 String?
  anyoneWorriedAboutMemory    Boolean @default(false)
  memoryStatus                String?
  specifyMemoryStatus         String?
  canTheyDoHouseKeeping       String?
  houseKeepingSupport         Boolean @default(false)
  houseKeepingAdditionalNotes String? @db.Text

  carePlan CarePlan @relation(fields: [carePlanId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([carePlanId])
}

model FoodNutritionHydration {
  id                                    String   @id @default(cuid())
  tenantId                              String
  carePlanId                            String   @unique
  dietaryRequirements                   String?
  foodOrDrinkAllergies                  Boolean? @default(false)
  foodAllergiesSpecification            String?
  allergiesImpact                       String?
  favouriteFoods                        String?
  foodTextures                          String?
  appetiteLevel                         String?
  swallowingDifficulties                String?
  medicationsAffectingSwallowing        String?
  specifyMedicationsAffectingSwallowing String?
  canFeedSelf                           String?
  canPrepareLightMeals                  String?
  canCookMeals                          String?
  clientFoodGiver                       String?
  mealtimeSupport                       String?
  hydrationSchedule                     String?
  strongDislikes                        String?
  fluidPreferences                      String?

  carePlan CarePlan @relation(fields: [carePlanId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([carePlanId])
}

model RoutinePreference {
  id                             String           @id @default(cuid())
  tenantId                       String
  carePlanId                     String           @unique
  PersonalBiography              String?
  haveJob                        Boolean?         @default(false)
  aboutJob                       String?
  haveImportantPerson            Boolean?         @default(false)
  aboutImportantPerson           String?
  significantPersonHasLocation   Boolean?         @default(false)
  importantPersonLocationEffects String?
  canMaintainOralHygiene         String?
  careGiverGenderPreference      GenderPreference @default(NO_PREFERENCE)
  autonomyPreference             String?
  dailyRoutine                   String?
  haveSpecificImportantRoutine   Boolean?         @default(false)
  haveDislikes                   Boolean?         @default(false)
  dislikesEffect                 String?
  haveHobbiesRoutines            Boolean?         @default(false)
  hobbiesRoutinesEffect          String?

  carePlan CarePlan @relation(fields: [carePlanId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([carePlanId])
}

model CultureValues {
  id                                  String   @id @default(cuid())
  tenantId                            String
  carePlanId                          String   @unique
  religiousBackground                 String?
  ethnicGroup                         String?
  culturalAccommodation               String?
  sexualityandRelationshipPreferences String?
  sexImpartingCareNeeds               String?
  preferredLanguage                   String?
  communicationStyleNeeds             String[] @default([])
  preferredMethodOfCommunication      String?
  keyFamilyMembers                    String?
  receivesInformalCare                Boolean? @default(false)
  informalCareByWho                   String?
  supportMethodByInformalCare         String?
  concernsOnInformalCare              String?
  specifyConcernsOnInformalCare       String?
  receivesFormalCare                  Boolean? @default(false)
  specifyFormalCare                   String?
  socialGroupAndCommunity             String?
  emotionalSupportNeeds               String[] @default([])
  mentalWellbeingTracking             Boolean? @default(false)

  carePlan CarePlan @relation(fields: [carePlanId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([carePlanId])
}

model BodyMap {
  id                          String    @id @default(cuid())
  tenantId                    String
  carePlanId                  String    @unique
  visitFrequency              String?
  carePlanReviewDate          DateTime?
  invoicingCycle              String?
  fundingAndInsuranceDetails  String?
  assignedCareManager         String?
  initialClinicalObservations Boolean?  @default(false)
  initialSkinIntegrity        Boolean?  @default(false)
  type                        String?
  size                        String?
  locationDescription         String?
  dateFirstObserved           DateTime?
  weight                      String?
  height                      String?

  carePlan CarePlan @relation(fields: [carePlanId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([carePlanId])
}

model MovingHandling {
  id                              String      @id @default(cuid())
  tenantId                        String
  carePlanId                      String      @unique
  equipmentsNeeds                 String?
  anyPainDuringRestingAndMovement String?
  anyCognitiveImpairment          String?
  behaviouralChanges              Boolean?    @default(false)
  describeBehaviouralChanges      String?
  walkIndependently               Boolean?    @default(false)
  manageStairs                    Boolean?    @default(false)
  sittingToStandingDependence     String?
  limitedSittingBalance           Boolean?    @default(false)
  turnInBed                       Boolean?    @default(false)
  lyingToSittingDependence        Boolean?    @default(false)
  gettingUpFromChairDependence    String?
  bathOrShower                    String?
  chairToCommodeOrBed             Boolean?    @default(false)
  profilingBedAndMattress         Boolean?    @default(false)
  transferRisks                   String[]    @default([])
  behaviouralChallenges           String[]    @default([])
  riskManagementPlan              String?
  locationRiskReview              String?
  EvacuationPlanRequired          Boolean?    @default(false)
  dailyGoal                       String?
  IntakeLog                       IntakeLog[]

  carePlan CarePlan @relation(fields: [carePlanId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([carePlanId])
}

model IntakeLog {
  id               String  @id @default(cuid())
  tenantId         String
  movingHandlingId String
  time             String
  amount           String
  notes            String?

  MovingHandling MovingHandling @relation(fields: [movingHandlingId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([movingHandlingId])
}

model CareRequirements {
  id            String    @id @default(cuid())
  tenantId      String
  carePlanId    String    @unique
  careType      careType?
  // Optional contract boundaries for generated visits. When present these act as hard bounds
  // for visit generation (contractStart <= generated visits <= contractEnd).
  contractStart DateTime?
  contractEnd   DateTime?
  // Optional per-care-requirements override for how many rolling weeks to generate
  rollingWeeks  Int?

  // Normalized schedule: one AgreedCareSchedule per day for this CareRequirements
  schedules AgreedCareSchedule[]

  carePlan CarePlan @relation(fields: [carePlanId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([carePlanId])
}

enum careType {
  SINGLE_HANDED_CALL
  DOUBLE_HANDED_CALL
  SPECIALCARE
}

// Enum for days of week used by AgreedCareSchedule
enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

model AgreedCareSchedule {
  id                 String    @id @default(cuid())
  tenantId           String
  careRequirementsId String
  day                DayOfWeek
  enabled            Boolean   @default(false)
  lunchStart         String? // e.g. "13:00"
  lunchEnd           String? // e.g. "14:00"
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  // Relations
  careRequirements           CareRequirements            @relation(fields: [careRequirementsId], references: [id], onDelete: Cascade)
  slots                      AgreedCareSlot[]
  clusterAgreedCareSchedules ClusterAgreedCareSchedule[]

  @@unique([careRequirementsId, day])
  @@index([tenantId])
  @@index([careRequirementsId])
}

model ClusterAgreedCareSchedule {
  id                   String   @id @default(cuid())
  tenantId             String
  clusterId            String
  agreedCareScheduleId String
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  // Relations
  cluster            Cluster            @relation(fields: [clusterId], references: [id], onDelete: Cascade)
  agreedCareSchedule AgreedCareSchedule @relation(fields: [agreedCareScheduleId], references: [id], onDelete: Cascade)

  @@unique([tenantId, clusterId, agreedCareScheduleId], name: "tenant_cluster_schedule_unique")
  @@index([tenantId])
  @@index([clusterId])
  @@index([agreedCareScheduleId])
  @@map("cluster_agreed_care_schedules")
}

model ClusterClient {
  id        String   @id @default(cuid())
  tenantId  String
  clusterId String
  clientId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  cluster Cluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@unique([tenantId, clusterId, clientId], name: "tenant_cluster_client_unique")
  @@index([tenantId])
  @@index([clusterId])
  @@index([clientId])
  @@map("cluster_clients")
}

model AgreedCareSlot {
  id         String   @id @default(cuid())
  scheduleId String
  // time values stored as SQL TIME (HH:MM:SS). Use @db.Time to map to Postgres time type.
  // Prisma maps native SQL TIME to a DateTime field with @db.Time. Values will be handled as times.
  startTime  DateTime @db.Time
  endTime    DateTime @db.Time
  externalId String? // original client-provided id like "monday-default-0"
  position   Int? // ordering index within the day's slots
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  schedule AgreedCareSchedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)

  @@index([scheduleId])
}

model LegalRequirement {
  id                            String   @id @default(cuid())
  tenantId                      String
  carePlanId                    String   @unique
  attorneyInPlace               Boolean? @default(false)
  attorneyType                  String?
  attorneyName                  String?
  attorneyContact               String?
  attorneyEmail                 String?
  solicitor                     String?
  certificateNumber             String?
  certificateUpload             String?
  digitalConsentsAndPermissions String[] @default([])
  consertUpload                 String?

  carePlan CarePlan @relation(fields: [carePlanId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([carePlanId])
}

model Task {
  id              String     @id @default(cuid())
  tenantId        String
  carePlanId      String
  carerId         String?
  relatedTable    String
  relatedId       String
  title           String
  description     String     @db.Text
  status          TaskStatus @default(PENDING)
  riskCategory    String[]   @default([])
  riskFrequency   String
  startDate       DateTime?
  dueDate         DateTime?
  completedAt     DateTime?
  createdBy       String?
  additionalNotes String?    @db.Text

  carePlan     CarePlan    @relation(fields: [carePlanId], references: [id], onDelete: Cascade)
  carerVisitId String?
  carerVisit   CarerVisit? @relation(fields: [carerVisitId], references: [id], onDelete: Cascade)

  // When true the task was pushed into a CarerVisit at creation time
  pushToVisit Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId])
  @@index([carePlanId])
  @@index([relatedTable, relatedId])
  @@index([status])
  @@index([dueDate])
  @@index([carerVisitId])
  @@index([carerId])
  @@map("tasks")
}

model CarerVisit {
  id                    String               @id @default(cuid())
  tenantId              String
  careType              careType?
  // Reason for switching careType (required at API validation time when careType is changed)
  switchReason          String?
  // Optional explanatory comment when careType is changed
  switchComment         String?
  // carerId is nullable: visits may exist before a carer is assigned
  carerId               String?
  // optional reference to originating care plan
  carePlanId            String?
  // visit start/end times for scheduling
  startDate             DateTime?
  endDate               DateTime?
  // visit lifecycle status
  status                VisitStatus          @default(SCHEDULED)
  // timestamps for clocking in/out
  clockInAt             DateTime?
  clockOutAt            DateTime?
  // optional note recorded when clocking out
  clockOutNote          String?              @db.Text
  // flag to mark visits auto-generated from care plans
  generatedFromCarePlan Boolean              @default(false)
  // when a carer is assigned to the visit
  assignedAt            DateTime?
  tasks                 Task[]
  assignees             CarerVisitAssignee[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId])
  @@index([carePlanId])
  @@index([carerId])
  @@index([generatedFromCarePlan])
  @@map("carer_visits")
}

model ClientVisitLog {
  id            String      @id @default(cuid())
  tenantId      String
  visitId       String
  // The type of activity recorded
  action        VisitAction
  // Optional related task id (for task-completed events)
  taskId        String?
  // The id of the user who performed the action (could be carer id, staff id, system id)
  performedById String
  // Optional freeform comment or details
  details       String?     @db.Text
  // Any structured metadata
  meta          Json?

  createdAt DateTime @default(now())

  @@index([tenantId])
  @@index([visitId])
  @@index([action])
  @@map("client_visit_logs")
}

enum VisitAction {
  CLOCK_IN
  CLOCK_OUT
  CARETYPE_CHANGED
  TASK_COMPLETED
  TASK_MISSED
  VISIT_COMPLETED
  VISIT_CREATED
  VISIT_DELETED
  ASSIGNEE_ADDED
  ASSIGNEE_REMOVED
}

model CarerVisitAssignee {
  id           String   @id @default(cuid())
  tenantId     String
  carerVisitId String
  carerId      String
  assignedAt   DateTime @default(now())

  carerVisit CarerVisit @relation(fields: [carerVisitId], references: [id], onDelete: Cascade)

  @@unique([carerVisitId, carerId])
  @@index([tenantId, carerVisitId])
  @@map("carer_visit_assignees")
}

// ─────────────────────────────────────────────
// ROSTERING & SCHEDULING
// ─────────────────────────────────────────────

model RosteringConstraints {
  id       String @id @default(cuid())
  tenantId String @map("tenant_id")
  name     String @default("Default Rules")

  wtdMaxHoursPerWeek      Int @default(48) @map("wtd_max_hours_per_week")
  restPeriodHours         Int @default(11) @map("rest_period_hours")
  bufferMinutes           Int @default(5) @map("buffer_minutes")
  travelMaxMinutes        Int @default(20) @map("travel_max_minutes")
  continuityTargetPercent Int @default(85) @map("continuity_target_percent")

  maxDailyHours         Int? @default(10) @map("max_daily_hours")
  minRestBetweenVisits  Int? @default(0) @map("min_rest_between_visits")
  maxTravelTimePerVisit Int? @default(60) @map("max_travel_time_per_visit")

  isActive  Boolean? @default(true) @map("is_active")
  createdBy String?  @map("created_by")

  // NEW FIELDS FOR UPDATE TRACKING
  updatedBy          String? @map("updated_by")
  updatedByEmail     String? @map("updated_by_email")
  updatedByFirstName String? @map("updated_by_first_name")
  updatedByLastName  String? @map("updated_by_last_name")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([tenantId, name])
  @@map("rostering_constraints")
}

model TravelMatrixCache {
  id String @id @default(cuid())

  // Input identifiers (what user requested)
  fromAddress  String? @map("from_address")
  fromPostcode String  @map("from_postcode")
  toAddress    String? @map("to_address")
  toPostcode   String  @map("to_postcode")

  // Geocoded results from Google
  fromLatitude  Float? @map("from_latitude")
  fromLongitude Float? @map("from_longitude")
  toLatitude    Float? @map("to_latitude")
  toLongitude   Float? @map("to_longitude")

  // Distance/duration results
  distanceMeters         Int? @map("distance_meters")
  durationSeconds        Int? @map("duration_seconds")
  trafficDurationSeconds Int? @map("traffic_duration_seconds")

  mode String @default("driving")

  // Cache metadata
  precisionLevel PrecisionLevel @default(POSTCODE) @map("precision_level")
  calculatedAt   DateTime       @default(now()) @map("calculated_at")
  expiresAt      DateTime       @map("expires_at")

  // Add composite unique constraint
  @@unique([fromAddress, toAddress, mode], name: "address_pair_mode")
  @@unique([fromPostcode, toPostcode, mode], name: "postcode_pair_mode")
  @@index([fromPostcode, toPostcode])
  @@index([expiresAt])
  @@map("travel_matrix_cache")
}

enum PrecisionLevel {
  COORDINATES // Coordinates provided
  ADDRESS // Full address geocoded
  POSTCODE // Postcode centroid used
}

// ─────────────────────────────────────────────
// ROSTER GENERATION
// ─────────────────────────────────────────────

model Roster {
  id          String         @id @default(cuid())
  tenantId    String         @map("tenant_id")
  name        String
  description String?
  strategy    RosterStrategy @default(BALANCED)
  startDate   DateTime       @map("start_date")
  endDate     DateTime       @map("end_date")
  createdBy   String         @map("created_by")
  createdAt   DateTime       @default(now()) @map("created_at")
  updatedAt   DateTime       @updatedAt @map("updated_at")
  status      RosterStatus   @default(DRAFT)
  publishedAt DateTime?      @map("published_at")

  totalAssignments   Int   @default(0) @map("total_assignments")
  totalTravelMinutes Int   @default(0) @map("total_travel_minutes")
  continuityScore    Float @default(0) @map("continuity_score")
  qualityScore       Float @default(0) @map("quality_score")

  assignments  Assignment[]
  publications RosterPublication[]

  @@index([tenantId])
  @@index([startDate, endDate])
  @@index([status])
  @@map("rosters")
}

model Assignment {
  id                 String           @id @default(cuid())
  tenantId           String           @map("tenant_id")
  rosterId           String           @map("roster_id")
  visitId            String           @map("visit_id")
  carerId            String           @map("carer_id")
  scheduledTime      DateTime         @map("scheduled_time")
  estimatedEndTime   DateTime         @map("estimated_end_time")
  actualDuration     Int?             @map("actual_duration")
  travelFromPrevious Int              @default(0) @map("travel_from_previous")
  travelDistance     Float?           @map("travel_distance")
  wtdCompliant       Boolean          @default(true) @map("wtd_compliant")
  restPeriodOK       Boolean          @default(true) @map("rest_period_ok")
  travelTimeOK       Boolean          @default(true) @map("travel_time_ok")
  skillsMatch        Boolean          @default(true) @map("skills_match")
  warnings           String[]         @default([])
  status             AssignmentStatus @default(PENDING)
  acceptedAt         DateTime?        @map("accepted_at")
  declinedAt         DateTime?        @map("declined_at")
  declineReason      String?          @map("decline_reason")

  // NEW FIELDS - ADD THESE
  locked           Boolean   @default(false)
  lockedReason     String?   @map("locked_reason")
  lockedBy         String?   @map("locked_by")
  lockedAt         DateTime? @map("locked_at")
  manuallyAssigned Boolean   @default(false) @map("manually_assigned")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  roster               Roster                @relation(fields: [rosterId], references: [id], onDelete: Cascade)
  visit                Visit                 @relation(fields: [visitId], references: [id])
  carer                Carer                 @relation("CarerAssignments", fields: [carerId], references: [id])
  publishedAssignments PublishedAssignment[]

  @@unique([rosterId, visitId])
  @@index([tenantId])
  @@index([carerId])
  @@index([scheduledTime])
  @@index([status])
  @@index([locked]) // NEW INDEX
  @@map("assignments")
}

// ─────────────────────────────────────────────
// LIVE OPERATIONS
// ─────────────────────────────────────────────

model CarerLocationUpdate {
  id             String                                 @id @default(cuid())
  carerId        String                                 @map("carer_id")
  latitude       Float
  longitude      Float
  accuracy       Float
  location       Unsupported("geography(POINT, 4326)")?
  currentVisitId String?                                @map("current_visit_id")
  status         LocationStatus                         @default(UNKNOWN)
  recordedAt     DateTime                               @default(now()) @map("recorded_at")

  @@index([carerId])
  @@index([recordedAt])
  @@map("carer_location_updates")
}

model VisitCheckIn {
  id               String    @id @default(cuid())
  visitId          String    @map("visit_id")
  carerId          String    @map("carer_id")
  latitude         Float
  longitude        Float
  withinGeofence   Boolean   @default(true) @map("within_geofence")
  distance         Float
  checkInTime      DateTime  @default(now()) @map("check_in_time")
  notes            String?
  requiresApproval Boolean   @default(false) @map("requires_approval")
  approvedBy       String?   @map("approved_by")
  approvedAt       DateTime? @map("approved_at")

  visit Visit @relation(fields: [visitId], references: [id])

  @@unique([visitId, carerId])
  @@index([visitId])
  @@index([carerId])
  @@index([checkInTime])
  @@map("visit_check_ins")
}

model VisitCheckOut {
  id               String            @id @default(cuid())
  visitId          String            @map("visit_id")
  carerId          String            @map("carer_id")
  latitude         Float
  longitude        Float
  checkOutTime     DateTime          @default(now()) @map("check_out_time")
  actualDuration   Int               @map("actual_duration")
  tasksCompleted   String[]          @default([]) @map("tasks_completed")
  incidentReported Boolean           @default(false) @map("incident_reported")
  incidentDetails  String?           @map("incident_details")
  incidentSeverity IncidentSeverity? @map("incident_severity")
  notes            String?

  visit Visit @relation(fields: [visitId], references: [id])

  @@unique([visitId, carerId])
  @@index([visitId])
  @@index([carerId])
  @@index([checkOutTime])
  @@map("visit_check_outs")
}

model LatenessAlert {
  id               String         @id @default(cuid())
  tenantId         String         @map("tenant_id")
  visitId          String         @map("visit_id")
  carerId          String         @map("carer_id")
  scheduledTime    DateTime       @map("scheduled_time")
  estimatedArrival DateTime       @map("estimated_arrival")
  delayMinutes     Int            @map("delay_minutes")
  confidence       Float
  reason           LatenessReason @default(UNKNOWN)
  details          String?
  status           AlertStatus    @default(ACTIVE)
  resolvedAt       DateTime?      @map("resolved_at")
  resolution       String?
  clientNotified   Boolean        @default(false) @map("client_notified")
  swapSuggested    Boolean        @default(false) @map("swap_suggested")
  createdAt        DateTime       @default(now()) @map("created_at")

  visit Visit @relation(fields: [visitId], references: [id])

  @@index([tenantId])
  @@index([visitId])
  @@index([carerId])
  @@index([status])
  @@map("lateness_alerts")
}

model Incident {
  id               String           @id @default(cuid())
  tenantId         String           @map("tenant_id")
  visitId          String?          @map("visit_id")
  carerId          String?          @map("carer_id")
  clientId         String?          @map("client_id")
  type             IncidentType
  severity         IncidentSeverity
  title            String
  description      String           @db.Text
  latitude         Float?
  longitude        Float?
  status           IncidentStatus   @default(REPORTED)
  reportedAt       DateTime         @default(now()) @map("reported_at")
  reportedBy       String           @map("reported_by")
  acknowledgedAt   DateTime?        @map("acknowledged_at")
  acknowledgedBy   String?          @map("acknowledged_by")
  resolvedAt       DateTime?        @map("resolved_at")
  resolvedBy       String?          @map("resolved_by")
  resolution       String?
  requiresFollowUp Boolean          @default(false) @map("requires_follow_up")
  followUpNotes    String?          @map("follow_up_notes") @db.Text

  visit Visit? @relation(fields: [visitId], references: [id])

  @@index([tenantId])
  @@index([visitId])
  @@index([carerId])
  @@index([status])
  @@index([severity])
  @@map("incidents")
}

// ─────────────────────────────────────────────
// ROSTER PUBLICATION
// ─────────────────────────────────────────────

model AssignmentHistory {
  id                  String    @id @default(cuid())
  assignmentId        String    @map("assignment_id")
  tenantId            String    @map("tenant_id")
  changeType          String    @map("change_type")
  previousCarerId     String?   @map("previous_carer_id")
  newCarerId          String?   @map("new_carer_id")
  previousTime        DateTime? @map("previous_time")
  newTime             DateTime? @map("new_time")
  changedBy           String    @map("changed_by")
  changedByEmail      String?   @map("changed_by_email")
  reason              String?
  constraintOverrides Json?     @map("constraint_overrides")
  createdAt           DateTime  @default(now()) @map("created_at")

  @@index([assignmentId])
  @@index([tenantId])
  @@index([createdAt])
  @@map("assignment_history")
}

// Add these missing models to your schema

model TravelMatrix {
  id              String   @id @default(cuid())
  fromPostcode    String   @map("from_postcode")
  toPostcode      String   @map("to_postcode")
  durationMinutes Int      @map("duration_minutes")
  distanceMeters  Int      @map("distance_meters")
  lastUpdated     DateTime @default(now()) @map("last_updated")
  expiresAt       DateTime @map("expires_at")

  @@unique([fromPostcode, toPostcode])
  @@index([expiresAt])
  @@map("travel_matrix")
}

model ClientClusterDistance {
  id             String   @id @default(cuid())
  clientPostcode String   @map("client_postcode")
  clusterId      String   @map("cluster_id")
  distanceKm     Float    @map("distance_km")
  lastUpdated    DateTime @default(now()) @map("last_updated")
  expiresAt      DateTime @map("expires_at")

  cluster Cluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@unique([clientPostcode, clusterId])
  @@index([clientPostcode])
  @@index([clusterId])
  @@index([expiresAt])
  @@map("client_cluster_distances")
}

model VisitEligibility {
  id               String   @id @default(cuid())
  tenantId         String   @map("tenant_id")
  visitId          String   @map("visit_id")
  carerId          String   @map("carer_id")
  eligible         Boolean  @default(false)
  score            Float    @default(0)
  skillsMatch      Boolean  @default(false) @map("skills_match")
  credentialsValid Boolean  @default(false) @map("credentials_valid")
  available        Boolean  @default(false)
  preferencesMatch Boolean  @default(false) @map("preferences_match")
  travelTime       Int?     @map("travel_time")
  lastCalculated   DateTime @default(now()) @map("last_calculated")

  @@unique([visitId, carerId])
  @@index([tenantId])
  @@index([visitId])
  @@index([carerId])
  @@index([eligible])
  @@map("visit_eligibility")
}

model RosterVersion {
  id                 String   @id @default(cuid())
  tenantId           String   @map("tenant_id")
  rosterId           String   @map("roster_id")
  versionLabel       String   @map("version_label")
  publishedAt        DateTime @default(now()) @map("published_at")
  publishedBy        String   @map("published_by")
  acceptanceDeadline DateTime @map("acceptance_deadline")
  assignments        Json // Store assignments snapshot

  @@index([tenantId])
  @@index([rosterId])
  @@index([publishedAt])
  @@map("roster_versions")
}

// MISSING: Notification Optimization Service
model CarerNotificationPreference {
  id                    String    @id @default(cuid())
  tenantId              String    @map("tenant_id")
  carerId               String    @map("carer_id")
  preferredChannel      String    @default("push") @map("preferred_channel")
  bestResponseTimeStart String?   @map("best_response_time_start")
  bestResponseTimeEnd   String?   @map("best_response_time_end")
  averageResponseTime   Int?      @map("average_response_time") // in minutes
  notificationOptOut    Boolean   @default(false) @map("notification_opt_out")
  lastNotifiedAt        DateTime? @map("last_notified_at")

  @@unique([tenantId, carerId])
  @@index([tenantId])
  @@index([carerId])
  @@map("carer_notification_preferences")
}

// MISSING: Escalation History
model EscalationHistory {
  id                   String   @id @default(cuid())
  tenantId             String   @map("tenant_id")
  originalAssignmentId String   @map("original_assignment_id")
  escalatedFrom        String   @map("escalated_from") // carerId
  escalatedTo          String   @map("escalated_to") // carerId
  escalationReason     String   @map("escalation_reason")
  escalatedAt          DateTime @default(now()) @map("escalated_at")
  escalatedBy          String   @map("escalated_by")
  success              Boolean  @default(false)

  @@index([tenantId])
  @@index([originalAssignmentId])
  @@index([escalatedFrom])
  @@index([escalatedTo])
  @@map("escalation_history")
}

model ClusterMetrics {
  id           String   @id @default(cuid())
  tenantId     String   @map("tenant_id")
  clusterId    String   @map("cluster_id")
  calculatedAt DateTime @default(now()) @map("calculated_at")

  totalVisits     Int      @default(0) @map("total_visits")
  totalHours      Float    @default(0) @map("total_hours")
  averageDistance Float    @default(0) @map("average_distance")
  totalTravelTime Int      @default(0) @map("total_travel_time")
  skillCoverage   Float    @default(0) @map("skill_coverage")
  continuityRisk  Float    @default(0) @map("continuity_risk")
  requiredSkills  String[] @default([]) @map("required_skills")

  @@unique([clusterId, calculatedAt])
  @@index([tenantId])
  @@index([clusterId])
  @@map("cluster_metrics")
}

model RosterPublication {
  id                   String            @id @default(cuid())
  tenantId             String            @map("tenant_id")
  rosterId             String            @map("roster_id")
  versionLabel         String            @map("version_label")
  publishedBy          String            @map("published_by")
  publishedAt          DateTime          @default(now()) @map("published_at")
  acceptanceDeadline   DateTime          @map("acceptance_deadline")
  notificationChannels String[]          @default(["push"]) @map("notification_channels")
  status               PublicationStatus @default(ACTIVE)
  completedAt          DateTime?         @map("completed_at")
  expiredAt            DateTime?         @map("expired_at")
  totalAssignments     Int               @default(0) @map("total_assignments")
  acceptedCount        Int               @default(0) @map("accepted_count")
  declinedCount        Int               @default(0) @map("declined_count")
  pendingCount         Int               @default(0) @map("pending_count")
  expiredCount         Int               @default(0) @map("expired_count")
  notes                String?           @db.Text
  metadata             Json?

  // ADD THESE MISSING FIELDS:
  autoEscalate       Boolean @default(true) @map("auto_escalate")
  escalationDelay    Int     @default(30) @map("escalation_delay") // minutes
  maxEscalationCount Int     @default(3) @map("max_escalation_count")

  // ADD RELATIONSHIP:
  // rosterVersions      RosterVersion[]

  roster               Roster                @relation(fields: [rosterId], references: [id], onDelete: Cascade)
  publishedAssignments PublishedAssignment[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([tenantId])
  @@index([rosterId])
  @@index([publishedAt])
  @@index([status])
  @@map("roster_publications")
}

model PublishedAssignment {
  id                    String           @id @default(cuid())
  publicationId         String           @map("publication_id")
  assignmentId          String           @map("assignment_id")
  carerId               String           @map("carer_id")
  notificationSentAt    DateTime?        @map("notification_sent_at")
  notificationChannel   String?          @map("notification_channel")
  notificationDelivered Boolean          @default(false) @map("notification_delivered")
  status                AcceptanceStatus @default(PENDING)
  acceptedAt            DateTime?        @map("accepted_at")
  acceptedBy            String?          @map("accepted_by")
  declinedAt            DateTime?        @map("declined_at")
  declineReason         String?          @map("decline_reason")
  expiredAt             DateTime?        @map("expired_at")
  escalatedAt           DateTime?        @map("escalated_at")
  escalatedTo           String[]         @default([]) @map("escalated_to")
  escalationCount       Int              @default(0) @map("escalation_count")
  viewedAt              DateTime?        @map("viewed_at")
  responseTime          Int?             @map("response_time")
  createdAt             DateTime         @default(now()) @map("created_at")
  updatedAt             DateTime         @updatedAt @map("updated_at")

  // ADD THESE MISSING FIELDS:
  originalCarerId    String? @map("original_carer_id") // For tracking reassignments
  escalationLevel    Int     @default(0) @map("escalation_level")
  maxEscalationLevel Int     @default(3) @map("max_escalation_level")

  // ADD RELATIONSHIP:
  // escalationHistory   EscalationHistory[]

  publication RosterPublication @relation(fields: [publicationId], references: [id], onDelete: Cascade)
  assignment  Assignment        @relation(fields: [assignmentId], references: [id])
  carer       Carer             @relation(fields: [carerId], references: [id])

  @@unique([publicationId, assignmentId])
  @@index([carerId])
  @@index([status])
  @@index([notificationSentAt])
  @@map("published_assignments")
}

// ─────────────────────────────────────────────
// DISRUPTION MANAGEMENT
// ─────────────────────────────────────────────

model Disruption {
  id                  String             @id @default(cuid())
  tenantId            String             @map("tenant_id")
  type                DisruptionType
  severity            DisruptionSeverity
  title               String
  description         String             @db.Text
  affectedVisits      String[]           @default([]) @map("affected_visits")
  affectedCarers      String[]           @default([]) @map("affected_carers")
  affectedClients     String[]           @default([]) @map("affected_clients")
  impactData          Json               @map("impact_data")
  status              DisruptionStatus   @default(REPORTED)
  reportedAt          DateTime           @default(now()) @map("reported_at")
  reportedBy          String             @map("reported_by")
  acknowledgedAt      DateTime?          @map("acknowledged_at")
  acknowledgedBy      String?            @map("acknowledged_by")
  analyzedAt          DateTime?          @map("analyzed_at")
  resolvedAt          DateTime?          @map("resolved_at")
  resolvedBy          String?            @map("resolved_by")
  resolution          String?            @db.Text
  resolutionOptions   Json?              @map("resolution_options")
  selectedResolution  String?            @map("selected_resolution")
  resolutionAppliedAt DateTime?          @map("resolution_applied_at")
  requiresFollowUp    Boolean            @default(false) @map("requires_follow_up")
  followUpNotes       String?            @map("follow_up_notes") @db.Text
  followUpAt          DateTime?          @map("follow_up_at")

  actions DisruptionAction[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([tenantId])
  @@index([status])
  @@index([severity])
  @@index([type])
  @@index([reportedAt])
  @@map("disruptions")
}

model DisruptionAction {
  id           String   @id @default(cuid())
  disruptionId String   @map("disruption_id")
  actionType   String   @map("action_type")
  actionData   Json     @map("action_data")
  performedBy  String   @map("performed_by")
  performedAt  DateTime @default(now()) @map("performed_at")
  success      Boolean  @default(true)
  errorMessage String?  @map("error_message")

  disruption Disruption @relation(fields: [disruptionId], references: [id], onDelete: Cascade)

  @@index([disruptionId])
  @@index([performedAt])
  @@map("disruption_actions")
}

// ─────────────────────────────────────────────
// SETTLEMENT & TIMESHEET
// ─────────────────────────────────────────────

model Timesheet {
  id              String          @id @default(cuid())
  tenantId        String          @map("tenant_id")
  carerId         String          @map("carer_id")
  periodStart     DateTime        @map("period_start")
  periodEnd       DateTime        @map("period_end")
  scheduledHours  Float           @map("scheduled_hours")
  actualHours     Float           @map("actual_hours")
  overtimeHours   Float           @default(0) @map("overtime_hours")
  breakHours      Float           @default(0) @map("break_hours")
  regularPay      Float           @default(0) @map("regular_pay")
  overtimePay     Float           @default(0) @map("overtime_pay")
  totalPay        Float           @default(0) @map("total_pay")
  status          TimesheetStatus @default(DRAFT)
  submittedAt     DateTime?       @map("submitted_at")
  approvedAt      DateTime?       @map("approved_at")
  approvedBy      String?         @map("approved_by")
  rejectedAt      DateTime?       @map("rejected_at")
  rejectedBy      String?         @map("rejected_by")
  rejectionReason String?         @map("rejection_reason")
  processedAt     DateTime?       @map("processed_at")
  processedBy     String?         @map("processed_by")
  payrollBatchId  String?         @map("payroll_batch_id")

  carer       Carer                 @relation(fields: [carerId], references: [id])
  entries     TimesheetEntry[]
  exceptions  TimesheetException[]
  adjustments TimesheetAdjustment[]
  payslips    Payslip[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([tenantId, carerId, periodStart])
  @@index([tenantId])
  @@index([carerId])
  @@index([status])
  @@index([periodStart, periodEnd])
  @@map("timesheets")
}

model TimesheetEntry {
  id                String    @id @default(cuid())
  timesheetId       String    @map("timesheet_id")
  visitId           String?   @map("visit_id")
  checkInTime       DateTime  @map("check_in_time")
  checkOutTime      DateTime? @map("check_out_time")
  scheduledStart    DateTime  @map("scheduled_start")
  scheduledEnd      DateTime  @map("scheduled_end")
  scheduledDuration Int       @map("scheduled_duration")
  actualDuration    Int?      @map("actual_duration")
  variance          Int?
  checkInLocation   Json?     @map("check_in_location")
  checkOutLocation  Json?     @map("check_out_location")
  withinGeofence    Boolean   @default(true) @map("within_geofence")
  tasksCompleted    String[]  @default([]) @map("tasks_completed")
  notes             String?   @db.Text
  validated         Boolean   @default(false)
  validatedAt       DateTime? @map("validated_at")
  validatedBy       String?   @map("validated_by")

  timesheet Timesheet @relation(fields: [timesheetId], references: [id], onDelete: Cascade)
  visit     Visit?    @relation(fields: [visitId], references: [id])

  @@index([timesheetId])
  @@index([visitId])
  @@map("timesheet_entries")
}

model TimesheetException {
  id              String            @id @default(cuid())
  timesheetId     String            @map("timesheet_id")
  entryId         String?           @map("entry_id")
  type            ExceptionType
  severity        ExceptionSeverity
  description     String            @db.Text
  expectedValue   String?           @map("expected_value")
  actualValue     String?           @map("actual_value")
  variance        String?
  status          ExceptionStatus   @default(PENDING)
  resolvedAt      DateTime?         @map("resolved_at")
  resolvedBy      String?           @map("resolved_by")
  resolution      String?           @db.Text
  suggestedAction String?           @map("suggested_action")
  autoResolvable  Boolean           @default(false) @map("auto_resolvable")

  timesheet Timesheet @relation(fields: [timesheetId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([timesheetId])
  @@index([status])
  @@index([type])
  @@map("timesheet_exceptions")
}

model TimesheetAdjustment {
  id              String         @id @default(cuid())
  timesheetId     String         @map("timesheet_id")
  adjustmentType  AdjustmentType @map("adjustment_type")
  description     String         @db.Text
  hoursAdjustment Float          @default(0) @map("hours_adjustment")
  payAdjustment   Float          @default(0) @map("pay_adjustment")
  reason          String         @db.Text
  approvedBy      String         @map("approved_by")
  approvedAt      DateTime       @default(now()) @map("approved_at")

  timesheet Timesheet @relation(fields: [timesheetId], references: [id], onDelete: Cascade)

  @@index([timesheetId])
  @@map("timesheet_adjustments")
}

// ─────────────────────────────────────────────
// INVOICE & PAYROLL
// ─────────────────────────────────────────────

model Invoice {
  id            String        @id @default(cuid())
  tenantId      String        @map("tenant_id")
  clientId      String?       @map("client_id")
  invoiceNumber String        @unique @map("invoice_number")
  invoiceDate   DateTime      @default(now()) @map("invoice_date")
  dueDate       DateTime      @map("due_date")
  periodStart   DateTime      @map("period_start")
  periodEnd     DateTime      @map("period_end")
  subtotal      Float         @default(0)
  taxAmount     Float         @default(0) @map("tax_amount")
  taxRate       Float         @default(0) @map("tax_rate")
  totalAmount   Float         @default(0) @map("total_amount")
  status        InvoiceStatus @default(DRAFT)
  paidAmount    Float         @default(0) @map("paid_amount")
  paidAt        DateTime?     @map("paid_at")
  purchaseOrder String?       @map("purchase_order")
  contractRef   String?       @map("contract_ref")
  notes         String?       @db.Text
  terms         String?       @db.Text

  lineItems InvoiceLineItem[]
  payments  InvoicePayment[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([tenantId])
  @@index([clientId])
  @@index([status])
  @@index([invoiceDate])
  @@index([dueDate])
  @@map("invoices")
}

model InvoiceLineItem {
  id          String    @id @default(cuid())
  invoiceId   String    @map("invoice_id")
  visitId     String?   @map("visit_id")
  description String    @db.Text
  quantity    Float     @default(1)
  unitPrice   Float     @map("unit_price")
  lineTotal   Float     @map("line_total")
  serviceDate DateTime? @map("service_date")
  category    String?

  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  visit   Visit?  @relation(fields: [visitId], references: [id])

  @@index([invoiceId])
  @@index([visitId])
  @@map("invoice_line_items")
}

model InvoicePayment {
  id            String   @id @default(cuid())
  invoiceId     String   @map("invoice_id")
  amount        Float
  paymentDate   DateTime @default(now()) @map("payment_date")
  paymentMethod String   @map("payment_method")
  reference     String?
  notes         String?  @db.Text
  processedBy   String   @map("processed_by")

  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([invoiceId])
  @@map("invoice_payments")
}

model PayrollBatch {
  id            String        @id @default(cuid())
  tenantId      String        @map("tenant_id")
  batchNumber   String        @unique @map("batch_number")
  periodStart   DateTime      @map("period_start")
  periodEnd     DateTime      @map("period_end")
  status        PayrollStatus @default(PROCESSING)
  totalGrossPay Float         @default(0) @map("total_gross_pay")
  totalNetPay   Float         @default(0) @map("total_net_pay")
  totalTax      Float         @default(0) @map("total_tax")
  totalNI       Float         @default(0) @map("total_ni")
  totalPension  Float         @default(0) @map("total_pension")
  employeeCount Int           @default(0) @map("employee_count")
  processedAt   DateTime?     @map("processed_at")
  processedBy   String?       @map("processed_by")
  approvedAt    DateTime?     @map("approved_at")
  approvedBy    String?       @map("approved_by")
  exportedAt    DateTime?     @map("exported_at")
  exportPath    String?       @map("export_path")

  payslips Payslip[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([tenantId])
  @@index([status])
  @@index([periodStart, periodEnd])
  @@map("payroll_batches")
}

model Payslip {
  id               String        @id @default(cuid())
  batchId          String        @map("batch_id")
  carerId          String        @map("carer_id")
  timesheetId      String?       @map("timesheet_id")
  periodStart      DateTime      @map("period_start")
  periodEnd        DateTime      @map("period_end")
  regularHours     Float         @map("regular_hours")
  overtimeHours    Float         @default(0) @map("overtime_hours")
  totalHours       Float         @map("total_hours")
  regularPay       Float         @map("regular_pay")
  overtimePay      Float         @default(0) @map("overtime_pay")
  grossPay         Float         @map("gross_pay")
  taxDeduction     Float         @default(0) @map("tax_deduction")
  niDeduction      Float         @default(0) @map("ni_deduction")
  pensionDeduction Float         @default(0) @map("pension_deduction")
  otherDeductions  Float         @default(0) @map("other_deductions")
  totalDeductions  Float         @default(0) @map("total_deductions")
  netPay           Float         @map("net_pay")
  status           PayslipStatus @default(GENERATED)
  sentAt           DateTime?     @map("sent_at")
  viewedAt         DateTime?     @map("viewed_at")

  batch     PayrollBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)
  carer     Carer        @relation(fields: [carerId], references: [id])
  timesheet Timesheet?   @relation(fields: [timesheetId], references: [id])

  @@index([batchId])
  @@index([carerId])
  @@index([status])
  @@map("payslips")
}

// ─────────────────────────────────────────────
// COMPLIANCE REPORTS
// ─────────────────────────────────────────────

model ComplianceReport {
  id           String               @id @default(cuid())
  tenantId     String               @map("tenant_id")
  reportType   ComplianceReportType @map("report_type")
  title        String
  periodStart  DateTime             @map("period_start")
  periodEnd    DateTime             @map("period_end")
  reportData   Json                 @map("report_data")
  summary      Json?
  passRate     Float?               @map("pass_rate")
  failCount    Int?                 @map("fail_count")
  warningCount Int?                 @map("warning_count")
  status       ReportStatus         @default(GENERATING)
  generatedAt  DateTime?            @map("generated_at")
  generatedBy  String?              @map("generated_by")
  exportPath   String?              @map("export_path")
  exportFormat String?              @map("export_format")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([tenantId])
  @@index([reportType])
  @@index([periodStart, periodEnd])
  @@map("compliance_reports")
}

// ─────────────────────────────────────────────
// ENUMS
// ─────────────────────────────────────────────

enum RequestUrgency {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum RequestStatus {
  PENDING
  PROCESSING
  MATCHED
  APPROVED
  COMPLETED
  DECLINED
  FAILED
}

enum VisitStatus {
  SCHEDULED
  ASSIGNED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum MatchStatus {
  PENDING
  SENT
  OPENED
  ACCEPTED
  DECLINED
  EXPIRED
  CANCELLED
}

enum MatchResponse {
  ACCEPTED
  DECLINED
  INTERESTED
}

enum ProcessingStatus {
  SUCCESS
  FAILED
  DUPLICATE
  INVALID_FORMAT
  GEOCODING_FAILED
}

enum CarePlanStatus {
  ACTIVE
  INACTIVE
  COMPLETED
}

enum BathingAssistance {
  YES_INDEPENDENTLY
  YES_WITH_HELP
  NO_NEEDS_FULL_ASSISTANCE
}

enum MobilityLevel {
  INDEPENDENT
  DEPENDENT
  INDEPENDENT_WITH_AIDS
  IMMOBILE
}

enum MobilitySupport {
  WALKING_STICK
  WHEELCHAIR
  NONE
  OTHERS
}

enum GenderPreference {
  NO_PREFERENCE
  MALE
  FEMALE
  NON_BINARY
  OTHER
}

enum TaskStatus {
  PENDING
  IN_PROGRESS
  MISSED
  COMPLETED
  CANCELLED
  ON_HOLD
}

enum RosterStrategy {
  CONTINUITY
  TRAVEL
  BALANCED
}

enum RosterStatus {
  DRAFT
  PENDING_APPROVAL
  APPROVED
  PUBLISHED
  ACTIVE
  COMPLETED
  CANCELLED
}

enum AssignmentStatus {
  PENDING
  OFFERED
  ACCEPTED
  DECLINED
  EXPIRED
  COMPLETED
  CANCELLED
}

enum PublicationStatus {
  ACTIVE
  COMPLETED
  EXPIRED
  CANCELLED
}

enum AcceptanceStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
  ESCALATED
}

enum LocationStatus {
  ON_TIME
  RUNNING_LATE
  OVERDUE
  UPCOMING
  COMPLETED
  UNKNOWN
}

enum LatenessReason {
  TRAFFIC
  PREVIOUS_OVERRUN
  DISTANCE
  EMERGENCY
  UNKNOWN
}

enum AlertStatus {
  ACTIVE
  ACKNOWLEDGED
  RESOLVED
  DISMISSED
}

enum IncidentType {
  FALL
  MEDICATION_ERROR
  EQUIPMENT_FAILURE
  SAFEGUARDING
  DELAY
  MISSED_VISIT
  CLIENT_COMPLAINT
  OTHER
}

enum IncidentSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum IncidentStatus {
  REPORTED
  ACKNOWLEDGED
  INVESTIGATING
  RESOLVED
  ESCALATED
}

enum DisruptionType {
  CARER_SICK
  CARER_UNAVAILABLE
  VISIT_CANCELLED
  EMERGENCY_VISIT
  DELAY
  EQUIPMENT_FAILURE
  WEATHER
  TRANSPORT_ISSUE
  OTHER
}

enum DisruptionSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum DisruptionStatus {
  REPORTED
  ACKNOWLEDGED
  ANALYZING
  RESOLVING
  RESOLVED
  ESCALATED
}

enum TimesheetStatus {
  DRAFT
  SUBMITTED
  APPROVED
  REJECTED
  PROCESSED
}

enum ExceptionType {
  MISSING_CHECK_OUT
  SHORT_VISIT
  LONG_VISIT
  OUTSIDE_GEOFENCE
  MISSING_TASKS
  TIME_CONFLICT
  OVERTIME_EXCEEDED
  OTHER
}

enum ExceptionSeverity {
  INFO
  WARNING
  ERROR
  CRITICAL
}

enum ExceptionStatus {
  PENDING
  ACKNOWLEDGED
  RESOLVED
  ESCALATED
}

enum AdjustmentType {
  MANUAL_CORRECTION
  OVERTIME_APPROVAL
  BONUS
  DEDUCTION
  MILEAGE
  EXPENSE
  OTHER
}

enum InvoiceStatus {
  DRAFT
  SENT
  VIEWED
  PAID
  OVERDUE
  CANCELLED
  PARTIAL
}

enum PayrollStatus {
  PROCESSING
  PENDING_APPROVAL
  APPROVED
  EXPORTED
  COMPLETED
  FAILED
}

enum PayslipStatus {
  GENERATED
  SENT
  VIEWED
  ACKNOWLEDGED
}

enum ComplianceReportType {
  WTD_COMPLIANCE
  REST_PERIOD
  VISIT_PUNCTUALITY
  CONTINUITY
  SKILL_COVERAGE
  TIMESHEET_ACCURACY
  FINANCIAL_SUMMARY
}

enum ReportStatus {
  GENERATING
  COMPLETED
  FAILED
}
