why is my background cv screening not starting automatically


# drf-spectacular: Add Bearer token security scheme for Swagger UI
SPECTACULAR_SETTINGS = {
    'TITLE': 'Talent Engine API',
    'DESCRIPTION': 'API documentation for Talent Engine microservice',
    'VERSION': '1.0.0',
    'SERVE_INCLUDE_SCHEMA': False,
    'SWAGGER_UI_SETTINGS': {
        'persistAuthorization': True,
    },
    'COMPONENT_SPLIT_REQUEST': True,
    'SECURITY': [{"BearerAuth": []}],
    'SECURITY_SCHEMES': {
        'BearerAuth': {
            'type': 'http',
            'scheme': 'bearer',
            'bearerFormat': 'JWT',
        },
    },
}

import django.http.request
from celery.schedules import crontab
def patched_split_domain_port(host):
    # Accept underscores in hostnames
    if host and host.count(':') == 1 and host.rfind(']') < host.find(':'):
        host, port = host.split(':', 1)
    else:
        port = ''
    return host, port

django.http.request.split_domain_port = patched_split_domain_port

import os
from pathlib import Path
import environ
from django.core.exceptions import ImproperlyConfigured
from django.utils.translation import gettext_lazy as _
from datetime import timedelta
import logging

# ======================== Base Dir & Env ========================
BASE_DIR = Path(__file__).resolve().parent.parent
env = environ.Env()
environ.Env.read_env(os.path.join(BASE_DIR, '.env'))

DATABASE_ROUTERS = []

SECRET_KEY = env('DJANGO_SECRET_KEY')

DEBUG = env.bool('DEBUG', default=False)
ALLOWED_HOSTS = env.list("ALLOWED_HOSTS", default=[
    "localhost", "127.0.0.1", "job_applications", "0.0.0.0", "*", "job_applications:8001"
])
# ======================== Database ========================

DATABASES = {
    'default': {
        'ENGINE': 'django_tenants.postgresql_backend',
        'NAME': env('DB_NAME', default=''),
        'USER': env('DB_USER', default=''),
        'PASSWORD': env('DB_PASSWORD', default=''),
        'HOST': env('DB_HOST', default='localhost'),
        'PORT': env('DB_PORT', default='5432'),
        'CONN_MAX_AGE': 60,
    }
}



if not DATABASES['default']['ENGINE']:
    raise ImproperlyConfigured("DATABASES['default']['ENGINE'] must be set.")


INSTALLED_APPS = [
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'corsheaders',
    'django.contrib.auth',
    'django.contrib.staticfiles',
    'rest_framework',
    'drf_spectacular',
    'drf_yasg',
    'django_filters',
    'job_application',
    'django_extensions',
]

# ======================== Middleware ========================
# MIDDLEWARE = [
#     'corsheaders.middleware.CorsMiddleware',
#     'django.middleware.security.SecurityMiddleware',
#     'django.contrib.sessions.middleware.SessionMiddleware',
#     'django.middleware.common.CommonMiddleware',
#     'django.middleware.csrf.CsrfViewMiddleware',
#     'django.contrib.auth.middleware.AuthenticationMiddleware',      # <-- must come BEFORE your JWT middleware
#     'job_applications.middleware.MicroserviceRS256JWTMiddleware',   # <-- your JWT middleware
#     'django.contrib.messages.middleware.MessageMiddleware',
#     'django.middleware.clickjacking.XFrameOptionsMiddleware',
# ]
MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'job_applications.middleware.MicroserviceRS256JWTMiddleware',
    'job_applications.middleware.CustomTenantSchemaMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]


AUTHENTICATION_BACKENDS = ('django.contrib.auth.backends.ModelBackend',)

ROOT_URLCONF = 'job_applications.urls'
WSGI_APPLICATION = 'job_applications.wsgi.application'

# ======================== REST Framework ========================
# REST_FRAMEWORK = {
#     # Use only custom JWT middleware, not DRF JWTAuthentication
#     'DEFAULT_AUTHENTICATION_CLASSES': (),
#     'DEFAULT_PERMISSION_CLASSES': ('rest_framework.permissions.AllowAny',),
#     'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',
#     'DEFAULT_PARSER_CLASSES': [
#         'rest_framework.parsers.JSONParser',
#         'rest_framework.parsers.FormParser',
#         'rest_framework.parsers.MultiPartParser',
#     ],
# }

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (),  # Empty tuple - handled by middleware
    'DEFAULT_PERMISSION_CLASSES': ('rest_framework.permissions.AllowAny',),
        'DEFAULT_PARSER_CLASSES': [
        'rest_framework.parsers.JSONParser',
        'rest_framework.parsers.FormParser',
        'rest_framework.parsers.MultiPartParser',
    ],
    # ... other settings
}


# ======================== External Services ========================
AUTH_SERVICE_URL = env('AUTH_SERVICE_URL', default='http://auth-service:8001')
TALENT_ENGINE_URL = env('TALENT_ENGINE_URL', default='http://talent-engine:8002')
JOB_APPLICATIONS_URL = env('JOB_APPLICATIONS_URL', default='http://job-applications:8003')
NOTIFICATIONS_EVENT_URL = env('NOTIFICATIONS_EVENT_URL', default='http://app:3000/events/')
SUPABASE_URL = env('SUPABASE_URL', default='')
SUPABASE_KEY = env('SUPABASE_KEY', default='')
SUPABASE_BUCKET = env('SUPABASE_BUCKET', default='')

STORAGE_TYPE = env('STORAGE_TYPE', default='supabase')  # or 's3', 'azure', 'local', 'supabase'


KAFKA_BOOTSTRAP_SERVERS = env('KAFKA_BOOTSTRAP_SERVERS', default='localhost:9092')
KAFKA_TOPICS = {
    'requisition': 'requisition-events',
    'video_session': 'video-session-events',
    'participant': 'participant-events',
    'request': 'request-events',
    'tenant': 'tenant-events',
    'branch': 'branch-events',
    'user': 'user-events',
}

# ======================== CORS ========================
CORS_ALLOWED_ORIGINS = env.list('CORS_ALLOWED_ORIGINS', default=['http://localhost:3000'])
CORS_ALLOW_CREDENTIALS = True
CORS_ALLOW_METHODS = ['DELETE', 'GET', 'OPTIONS', 'PATCH', 'POST', 'PUT']
CORS_ALLOW_HEADERS = ['accept', 'authorization', 'content-type', 'origin', 'x-csrftoken', 'x-requested-with']

# ======================== Static & Media ========================
STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')
# STATICFILES_DIRS = [BASE_DIR / 'static']  # For dev, uncomment if needed

MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

# ======================== Templates ========================
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

# ======================== Logging ========================
LOG_DIR = os.path.join(BASE_DIR, 'job_applications_logs')
os.makedirs(LOG_DIR, exist_ok=True)

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{asctime} [{levelname}] {name}: {message}',
            'style': '{'
        },
        'simple': {
            'format': '[{levelname}] {message}',
            'style': '{'
        },
    },
    'handlers': {
        'file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': os.path.join(LOG_DIR, 'job_applications.log'),
            'maxBytes': 5 * 1024 * 1024,
            'backupCount': 5,
            'formatter': 'verbose',
        },
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'simple',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['file', 'console'],
            'level': 'INFO',
            'propagate': True,
        },
        'job_applications': {
            'handlers': ['file', 'console'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}

# ======================== Defaults ========================
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_TZ = True
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

CELERY_BROKER_URL = 'redis://job_app_redis:6379/0'
CELERY_RESULT_BACKEND = 'redis://job_app_redis:6379/0'


CELERY_BEAT_SCHEDULE = {
    'auto-screen-all-applications-every-10-minutes': {
        'task': 'job_application.tasks.auto_screen_all_applications',
        'schedule': 600.0,  # every 10 minutes
    },
}



# CELERY_BEAT_SCHEDULE = {
#     'auto-screen-all-applications-at-midnight': {
#         'task': 'job_application.tasks.auto_screen_all_applications',
#         'schedule': crontab(hour=0, minute=0),  # Runs daily at 00:00 (midnight)
#     },
# }




# CELERY_BEAT_SCHEDULE = {
#     'auto-screen-all-applications-every-morning': {
#         'task': 'job_application.tasks.auto_screen_all_applications',
#         'schedule': crontab(hour=8, minute=25),  # âœ… Runs daily at 8:15 AM
#     },
# }


# docker compose exec job-applications python manage.py makemigrations job_application
# docker compose exec job-applications python manage.py migrate



#celery_task.py

from celery import shared_task
from django.conf import settings
from job_application.models import JobApplication
from utils.screen import parse_resume, screen_resume, extract_resume_fields
from utils.email_utils import send_screening_notification
import requests
import mimetypes
import tempfile
import os
import logging

logger = logging.getLogger('job_applications')

@shared_task
def screen_resumes_task(job_requisition_id, tenant_id, document_type, num_candidates, applications_data, job_requisition):
    # job_requisition is now passed in, not fetched again

    document_type_lower = document_type.lower()
    allowed_docs = [doc.lower() for doc in (job_requisition.get('documents_required') or [])]
    if document_type_lower not in allowed_docs and document_type_lower not in ['resume', 'curriculum vitae (cv)']:
        logger.error(f"Invalid document type: {document_type}")
        return

    if not applications_data:
        applications = JobApplication.active_objects.filter(
            job_requisition_id=job_requisition_id,
            # tenant_id=tenant_id,
            resume_status=True
        )
    else:
        application_ids = [app['application_id'] for app in applications_data]
        applications = JobApplication.active_objects.filter(
            job_requisition_id=job_requisition_id,
            # tenant_id=tenant_id,
            id__in=application_ids,
            resume_status=True
        )

    logger.info(f"Screening {applications.count()} applications")
    if not applications.exists():
        logger.warning("No applications with resume_status=True found.")
        return

    def download_resume(app, app_data, document_type_lower):
        try:
            if app_data and 'file_url' in app_data:
                file_url = app_data['file_url']
            else:
                cv_doc = next(
                    (doc for doc in app.documents if doc['document_type'].lower() == document_type_lower),
                    None
                )
                if not cv_doc:
                    app.screening_status = 'failed'
                    app.screening_score = 0.0
                    app.save()
                    return {"app": app, "success": False, "error": f"No {document_type} document found"}
                file_url = cv_doc['file_url']

            headers = {"Authorization": f"Bearer {settings.SUPABASE_KEY}"}
            response = requests.get(file_url, headers=headers, timeout=10)
            if response.status_code != 200:
                app.screening_status = 'failed'
                app.screening_score = 0.0
                app.save()
                return {"app": app, "success": False, "error": f"Failed to download resume from {file_url}"}

            content_type = response.headers.get('content-type', '')
            file_ext = mimetypes.guess_extension(content_type) or os.path.splitext(file_url)[1] or '.pdf'
            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=file_ext)
            temp_file.write(response.content)
            temp_file.close()
            temp_file_path = temp_file.name
            return {"app": app, "success": True, "temp_file_path": temp_file_path, "file_url": file_url}
        except Exception as e:
            app.screening_status = 'failed'
            app.screening_score = 0.0
            app.save()
            return {"app": app, "success": False, "error": f"Download error: {str(e)}"}

    # Download resumes
    download_results = []
    applications_list = list(applications)
    applications_data_map = {str(a['application_id']): a for a in applications_data}
    for app in applications_list:
        result = download_resume(app, applications_data_map.get(str(app.id)), document_type_lower)
        download_results.append(result)

    job_requirements = (
        (job_requisition.get('job_description') or '') + ' ' +
        (job_requisition.get('qualification_requirement') or '') + ' ' +
        (job_requisition.get('experience_requirement') or '') + ' ' +
        (job_requisition.get('knowledge_requirement') or '')
    ).strip()

    def parse_and_screen(result, job_requirements):
        app = result["app"]
        if not result["success"]:
            return {
                "application_id": str(app.id),
                "full_name": app.full_name,
                "email": app.email,
                "error": result["error"],
                "success": False
            }
        temp_file_path = result["temp_file_path"]
        file_url = result.get("file_url", "")
        try:
            resume_text = parse_resume(temp_file_path)
            if temp_file_path and os.path.exists(temp_file_path):
                os.unlink(temp_file_path)
            if not resume_text:
                app.screening_status = 'failed'
                app.screening_score = 0.0
                app.save()
                return {
                    "application_id": str(app.id),
                    "full_name": app.full_name,
                    "email": app.email,
                    "error": f"Failed to parse resume for file: {file_url}",
                    "success": False
                }
            score = screen_resume(resume_text, job_requirements)
            resume_data = extract_resume_fields(resume_text)
            employment_gaps = resume_data.get("employment_gaps", [])
            app.screening_status = 'processed'
            app.screening_score = score
            app.employment_gaps = employment_gaps
            app.save()
            return {
                "application_id": str(app.id),
                "full_name": app.full_name,
                "email": app.email,
                "score": score,
                "screening_status": app.screening_status,
                "employment_gaps": employment_gaps,
                "success": True
            }
        except Exception as e:
            app.screening_status = 'failed'
            app.screening_score = 0.0
            app.save()
            if temp_file_path and os.path.exists(temp_file_path):
                os.unlink(temp_file_path)
            return {
                "application_id": str(app.id),
                "full_name": app.full_name,
                "email": app.email,
                "error": f"Screening error for file: {file_url} - {str(e)}",
                "success": False
            }

    results = []
    for result in download_results:
        results.append(parse_and_screen(result, job_requirements))

    shortlisted = [r for r in results if r.get("success")]
    failed_applications = [r for r in results if not r.get("success")]

    shortlisted.sort(key=lambda x: x['score'], reverse=True)
    final_shortlisted = shortlisted[:num_candidates]
    shortlisted_ids = {item['application_id'] for item in final_shortlisted}

    for app in applications:
        app_id_str = str(app.id)
        if app_id_str in shortlisted_ids:
            app.status = 'shortlisted'
            app.save()
            shortlisted_app = next((item for item in final_shortlisted if item['application_id'] == app_id_str), None)
            if shortlisted_app:
                shortlisted_app['job_requisition_id'] = job_requisition['id']
                shortlisted_app['status'] = 'shortlisted'
                employment_gaps = shortlisted_app.get('employment_gaps', [])
                event_type = "job.application.shortlisted.gaps" if employment_gaps else "job.application.shortlisted"
                send_screening_notification(
                    shortlisted_app,
                    # tenant_id,
                    event_type=event_type,
                    employment_gaps=employment_gaps
                )
        else:
            app.status = 'rejected'
            app.save()
            rejected_app = {
                "application_id": app_id_str,
                "full_name": app.full_name,
                "email": app.email,
                "job_requisition_id": job_requisition['id'],
                "status": "rejected",
                "score": getattr(app, "screening_score", None)
            }
            send_screening_notification(rejected_app, tenant_id, event_type="job.application.rejected")

    logger.info(f"Screening complete for job requisition {job_requisition_id}")

    # Automatically close the requisition via public endpoint
    close_url = f"{settings.TALENT_ENGINE_URL}/api/talent-engine/requisitions/public/close/{job_requisition_id}/"
    try:
        close_resp = requests.post(close_url, timeout=10)
        if close_resp.status_code == 200:
            logger.info(f"Job requisition {job_requisition_id} successfully closed via public endpoint.")
        else:
            logger.warning(f"Failed to close job requisition {job_requisition_id}: {close_resp.text}")
    except Exception as e:
        logger.error(f"Error closing job requisition {job_requisition_id} via public endpoint: {str(e)}")





#tasks.py

from celery import shared_task
from django.conf import settings
from job_application.models import JobApplication
from job_applications.celery_task import screen_resumes_task
import requests
import logging
from datetime import date

logger = logging.getLogger('job_applications')

@shared_task
def auto_screen_all_applications():
    # Fetch all published requisitions with future deadline (public endpoint)
    url = f"{settings.TALENT_ENGINE_URL}/api/talent-engine/requisitions/public/published/"
    try:
        resp = requests.get(url, timeout=10)
        resp.raise_for_status()
        data = resp.json()
    except Exception as e:
        logger.error(f"Failed to fetch published requisitions: {str(e)}")
        return

    today = date.today().isoformat()
    for requisition in data.get("results", []):
        # Only trigger screening if today is the deadline date
        if requisition.get("deadline_date") != today:
            continue

        job_requisition_id = requisition["id"]
        tenant_id = job_requisition_id.split('-')[0]  # Adjust if needed
        document_type = "resume"  # Or requisition['documents_required'][0] if available
        num_candidates = requisition.get("num_of_applications", 0)

        applications = JobApplication.active_objects.filter(
            job_requisition_id=job_requisition_id,
            # tenant_id=tenant_id,
            resume_status=True
        )
        applications_data = [
            {"application_id": app.id, "file_url": app.get_resume_url()} for app in applications
        ]

        # Pass the requisition object directly
        screen_resumes_task.delay(
            job_requisition_id,
            # tenant_id,
            document_type,
            num_candidates,
            applications_data,
            requisition
        )
        logger.info(f"Triggered screening for requisition {job_requisition_id} with {len(applications_data)} applications.")




PS C:\Users\CPT-003\Desktop\CRM\crm_micro_services_backed\job_applications> docker ps --format "$env:FORMAT"
ID      5e4f30e4f341
NAME    api_gateway-api_gateway-1
Image   api_gateway-api_gateway
PORTS   0.0.0.0:9090->9090/tcp, [::]:9090->9090/tcp
COMMAND "gunicorn --bind 0.0â€¦"
CREATED 2025-09-08 18:16:03 +0100 WAT
STATUS  Up 14 hours

ID      63fc3e9c6450
NAME    job-applications-celery
Image   job_applications-celery-worker
PORTS   8003/tcp
COMMAND "celery -A job_appliâ€¦"
CREATED 2025-09-08 18:03:38 +0100 WAT
STATUS  Up 14 hours

ID      518d55813cec
NAME    job-applications-celery-beat
Image   job_applications-celery-beat
PORTS   8003/tcp
COMMAND "celery -A job_appliâ€¦"
CREATED 2025-09-08 18:03:38 +0100 WAT
STATUS  Up 14 hours

ID      b48eaf396535
NAME    job-applications
Image   job_applications-job-applications
PORTS   0.0.0.0:8003->8003/tcp, [::]:8003->8003/tcp
COMMAND "sh -c 'python managâ€¦"
CREATED 2025-09-08 18:03:26 +0100 WAT
STATUS  Up 14 hours

ID      8cd8d9207788
NAME    job_app_postgres
Image   postgres:15
PORTS   0.0.0.0:5434->5432/tcp, [::]:5434->5432/tcp
COMMAND "docker-entrypoint.sâ€¦"
CREATED 2025-09-08 15:07:53 +0100 WAT
STATUS  Up 16 hours (healthy)

ID      474239fe1f20
NAME    job_app_redis
Image   redis:7
PORTS   0.0.0.0:6381->6379/tcp, [::]:6381->6379/tcp
COMMAND "docker-entrypoint.sâ€¦"
CREATED 2025-09-08 15:07:53 +0100 WAT
STATUS  Up 16 hours

ID      e2d631510cbf
NAME    docker-jitsi-meet-web-1
Image   jitsi/web:unstable
PORTS   0.0.0.0:8004->80/tcp, [::]:8004->80/tcp, 0.0.0.0:8443->443/tcp, [::]:8443->443/tcp
COMMAND "/init"
CREATED 2025-09-08 12:56:07 +0100 WAT
STATUS  Up 19 hours

ID      9a5ec9257b2b
NAME    docker-jitsi-meet-jvb-1
Image   jitsi/jvb:unstable
PORTS   0.0.0.0:10000->10000/udp, [::]:10000->10000/udp, 127.0.0.1:8081->8080/tcp
COMMAND "/init"
CREATED 2025-09-08 12:56:06 +0100 WAT
STATUS  Up 19 hours

ID      0edadb20894e
NAME    docker-jitsi-meet-jicofo-1
Image   jitsi/jicofo:unstable
PORTS   127.0.0.1:8888->8888/tcp
COMMAND "/init"
CREATED 2025-09-08 12:56:06 +0100 WAT
STATUS  Up 19 hours

ID      4819fd772a9b
NAME    docker-jitsi-meet-prosody-1
Image   jitsi/prosody:unstable
PORTS   5222/tcp, 5269/tcp, 5280/tcp, 5347/tcp
COMMAND "/init"
CREATED 2025-09-08 12:56:05 +0100 WAT
STATUS  Up 19 hours

ID      0baf7d764b24
NAME    talent_engine
Image   talent_engine-talent-engine
PORTS   0.0.0.0:8002->8002/tcp, [::]:8002->8002/tcp
COMMAND "/app/entrypoint.sh"
CREATED 2025-09-08 12:15:00 +0100 WAT
STATUS  Up 20 hours

ID      986a7440259a
NAME    kafka-consumer
Image   talent_engine-kafka-consumer
PORTS   8002/tcp
COMMAND "sh -c './wait-for-iâ€¦"
CREATED 2025-09-08 12:14:59 +0100 WAT
STATUS  Up 20 hours

ID      99375ef2d6d6
NAME    key-rotator
Image   auth_service-key-rotator
PORTS
COMMAND "/app/entrypoint.sh â€¦"
CREATED 2025-09-08 10:09:09 +0100 WAT
STATUS  Up 22 hours

ID      aee513b06dec
NAME    auth-service
Image   auth_service-auth-service
PORTS   0.0.0.0:8001->8001/tcp, [::]:8001->8001/tcp
COMMAND "/app/entrypoint.sh"
CREATED 2025-09-08 10:08:57 +0100 WAT
STATUS  Up 22 hours

ID      50f22ea4a106
NAME    notifications_app-db-1
Image   postgres:15
PORTS   0.0.0.0:5440->5432/tcp, [::]:5440->5432/tcp
COMMAND "docker-entrypoint.sâ€¦"
CREATED 2025-09-05 10:00:51 +0100 WAT
STATUS  Up 24 hours (healthy)

ID      4f9fb08e4d2c
NAME    talent_postgres
Image   postgres:15
PORTS   0.0.0.0:5433->5432/tcp, [::]:5433->5432/tcp
COMMAND "docker-entrypoint.sâ€¦"
CREATED 2025-09-05 09:56:19 +0100 WAT
STATUS  Up 23 hours (healthy)

ID      511dcf65eeea
NAME    kafka
Image   confluentinc/cp-kafka:7.0.1
PORTS   0.0.0.0:9092->9092/tcp, [::]:9092->9092/tcp
COMMAND "/etc/confluent/dockâ€¦"
CREATED 2025-09-05 09:54:32 +0100 WAT
STATUS  Up 23 hours

ID      504dccefb944
NAME    auth_postgres
Image   postgres:15
PORTS   0.0.0.0:5411->5432/tcp, [::]:5411->5432/tcp
COMMAND "docker-entrypoint.sâ€¦"
CREATED 2025-09-05 09:54:31 +0100 WAT
STATUS  Up 23 hours (healthy)

ID      6f1ccdf5cdc0
NAME    zookeeper
Image   confluentinc/cp-zookeeper:7.0.1
PORTS   0.0.0.0:2181->2181/tcp, [::]:2181->2181/tcp
COMMAND "/etc/confluent/dockâ€¦"
CREATED 2025-09-05 09:54:30 +0100 WAT
STATUS  Up 23 hours

PS C:\Users\CPT-003\Desktop\CRM\crm_micro_services_backed\job_applications> docker logs job-applications-celery-beat
celery beat v5.5.3 (immunity) is starting.
__    -    ... __   -        _
LocalTime -> 2025-09-08 17:04:05
Configuration ->
    . broker -> redis://job_app_redis:6379/0
    . loader -> celery.loaders.app.AppLoader
    . scheduler -> celery.beat.PersistentScheduler
    . db -> celerybeat-schedule
    . logfile -> [stderr]@%INFO
    . maxinterval -> 5.00 minutes (300s)
[2025-09-08 17:04:05,176: INFO/MainProcess] beat: Starting...
[2025-09-08 17:09:31,056: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 17:19:32,439: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 17:29:33,857: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 17:39:35,319: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 17:49:36,976: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 18:40:28,417: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 18:50:28,444: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 19:00:28,444: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 19:10:28,444: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applicatio[2025-09-08 17:09:31,056: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 17:19:32,439: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 17:29:33,857: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 17:39:35,319: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 17:49:36,976: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 18:40:28,417: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 18:50:28,444: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 19:00:28,444: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 19:10:28,444: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 17:29:33,857: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 17:39:35,319: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 17:49:36,976: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 18:40:28,417: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 18:50:28,444: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 19:00:28,444: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 19:10:28,444: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 18:40:28,417: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 18:50:28,444: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 19:00:28,444: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 19:10:28,444: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 18:50:28,444: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 19:00:28,444: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 19:10:28,444: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 19:00:28,444: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 19:10:28,444: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 19:10:28,444: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 19:10:28,444: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
ns)
[2025-09-08 19:20:28,445: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applicatio[2025-09-08 19:20:28,445: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 19:30:28,445: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 19:40:28,445: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 20:03:06,867: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 19:40:28,445: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 20:03:06,867: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 20:03:06,867: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-08 20:13:06,868: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-09 06:54:28,573: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-09 07:04:28,573: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
[2025-09-09 07:14:28,574: INFO/MainProcess] Scheduler: Sending due task auto-screen-all-applications-every-10-minutes (job_application.tasks.auto_screen_all_applications)
PS C:\Users\CPT-003\Desktop\CRM\crm_micro_services_backed\job_applications>





{
  "count": 2,
  "results": [
    {
      "id": "PRO-0002",
      "requisition_number": null,
      "job_requisition_code": "PRO-JR-0002",
      "job_application_code": "PRO-JA-0002",
      "title": "Registered Nurse",
      "unique_link": "3-PRO-registered-nurse-504c01d9",
      "status": "open",
      "job_type": "contract",
      "position_type": "contract",
      "location_type": "on_site",
      "job_description": "Provide nursiWe are seeking kind and dedicated Care Assistants to provide personal care and support to elderly clients in their homes.We are seeking kind and dedicated Care Assistants to provide personal care and support to elderly clients in their homes.ng care for patients in a clinical environment.",
      "requirements": [
        "Valid Nursing License",
        "Minimum of 1 year clinical experience",
        "Basic life support certification"
      ],
      "qualification_requirement": "Diploma or BSc in Nursing",
      "experience_requirement": "1+ year in a hospital or clinic",
      "knowledge_requirement": "Knowledge of patient care protocols and emergency response",
      "urgency_level": "critical",
      "reason": "Staff shortage in emergency department",
      "deadline_date": "2025-09-09",
      "num_of_applications": 9,
      "start_date": "2025-10-17",
      "responsibilities": [
        "Monitor patient vitals",
        "Administer medications",
        "Document patient history",
        "We are seeking kind and dedicated Care Assistants to provide personal care and support to elderly clients in their homes."
      ],
      "advert_banner": null,
      "publish_status": true,
      "approval_workflow": {
        "steps": [
          "HR Approval",
          "Medical Director Approval"
        ]
      },
      "current_approval_stage": 0,
      "approval_date": null,
      "time_to_fill_days": null
    },
    {
      "id": "PRO-0005",
      "requisition_number": null,
      "job_requisition_code": "PRO-JR-0005",
      "job_application_code": "PRO-JA-0005",
      "title": "Corporate Legal Counsel",
      "unique_link": "3-PRO-corporate-legal-counsel-43768bc9",
      "status": "open",
      "job_type": "full_time",
      "position_type": "permanent",
      "location_type": "on_site",
      "job_description": "Review and draft contracts",
      "requirements": [],
      "qualification_requirement": "As a Corporate Legal Counsel, you will provide legal advice to ensure compliance with corporate laws, draft legal documents, and support business transactions.",
      "experience_requirement": "Minimum of 5 years in a legal advisory or corporate legal role.",
      "knowledge_requirement": "Expert knowledge of company law, mergers & acquisitions, and regulatory compliance in Nigeria.",
      "urgency_level": "medium",
      "reason": "Expansion of legal department due to increased commercial activity.",
      "deadline_date": "2025-09-09",
      "num_of_applications": 1,
      "start_date": "2025-09-30",
      "responsibilities": [
        "Review and draft contracts"
      ],
      "advert_banner": null,
      "publish_status": true,
      "approval_workflow": {},
      "current_approval_stage": 0,
      "approval_date": null,
      "time_to_fill_days": null
    }
  ]
}
{
  "count": 2,
  "results": [
    {
      "id": "PRO-0002",
      "requisition_number": null,
      "job_requisition_code": "PRO-JR-0002",
      "job_application_code": "PRO-JA-0002",
      "title": "Registered Nurse",
      "unique_link": "3-PRO-registered-nurse-504c01d9",
      "status": "open",
      "job_type": "contract",
      "position_type": "contract",
      "location_type": "on_site",
      "job_description": "Provide nursiWe are seeking kind and dedicated Care Assistants to provide personal care and support to elderly clients in their homes.We are seeking kind and dedicated Care Assistants to provide personal care and support to elderly clients in their homes.ng care for patients in a clinical environment.",
      "requirements": [
        "Valid Nursing License",
        "Minimum of 1 year clinical experience",
        "Basic life support certification"
      ],
      "qualification_requirement": "Diploma or BSc in Nursing",
      "experience_requirement": "1+ year in a hospital or clinic",
      "knowledge_requirement": "Knowledge of patient care protocols and emergency response",
      "urgency_level": "critical",
      "reason": "Staff shortage in emergency department",
      "deadline_date": "2025-09-09",
      "num_of_applications": 9,
      "start_date": "2025-10-17",
      "responsibilities": [
        "Monitor patient vitals",
        "Administer medications",
        "Document patient history",
        "We are seeking kind and dedicated Care Assistants to provide personal care and support to elderly clients in their homes."
      ],
      "advert_banner": null,
      "publish_status": true,
      "approval_workflow": {
        "steps": [
          "HR Approval",
          "Medical Director Approval"
        ]
      },
      "current_approval_stage": 0,
      "approval_date": null,
      "time_to_fill_days": null
    },
    {
      "id": "PRO-0005",
      "requisition_number": null,
      "job_requisition_code": "PRO-JR-0005",
      "job_application_code": "PRO-JA-0005",
      "title": "Corporate Legal Counsel",
      "unique_link": "3-PRO-corporate-legal-counsel-43768bc9",
      "status": "open",
      "job_type": "full_time",
      "position_type": "permanent",
      "location_type": "on_site",
      "job_description": "Review and draft contracts",
      "requirements": [],
      "qualification_requirement": "As a Corporate Legal Counsel, you will provide legal advice to ensure compliance with corporate laws, draft legal documents, and support business transactions.",
      "experience_requirement": "Minimum of 5 years in a legal advisory or corporate legal role.",
      "knowledge_requirement": "Expert knowledge of company law, mergers & acquisitions, and regulatory compliance in Nigeria.",
      "urgency_level": "medium",
      "reason": "Expansion of legal department due to increased commercial activity.",
      "deadline_date": "2025-09-09",
      "num_of_applications": 1,
      "start_date": "2025-09-30",
      "responsibilities": [
        "Review and draft contracts"
      ],
      "advert_banner": null,
      "publish_status": true,
      "approval_workflow": {},
      "current_approval_stage": 0,
      "approval_date": null,
      "time_to_fill_days": null
    }
  ]
}

http://localhost:9090/api/talent-engine/requisitions/public/published/



but this view uses the same logic without any issues


class ResumeScreeningView(APIView):
    serializer_class = SimpleMessageSerializer
    parser_classes = [JSONParser, MultiPartParser, FormParser]

    def post(self, request, job_requisition_id):
        try:
            jwt_payload = getattr(request, 'jwt_payload', {})
            tenant_id = str(jwt_payload.get('tenant_id')) if jwt_payload.get('tenant_id') is not None else None
            role = jwt_payload.get('role')
            branch = jwt_payload.get('user', {}).get('branch')

            document_type = request.data.get('document_type')
            applications_data = request.data.get('applications', [])
            num_candidates = request.data.get('number_of_candidates')
            try:
                num_candidates = int(num_candidates)
            except (TypeError, ValueError):
                num_candidates = 0

            job_requisition = get_job_requisition_by_id(job_requisition_id, request)
            if not job_requisition:
                return Response({"detail": "Job requisition not found."}, status=status.HTTP_404_NOT_FOUND)

            if not document_type:
                return Response({"detail": "Document type is required."}, status=status.HTTP_400_BAD_REQUEST)

            document_type_lower = document_type.lower()
            allowed_docs = [doc.lower() for doc in (job_requisition.get('documents_required') or [])]
            if document_type_lower not in allowed_docs and document_type_lower not in ['resume', 'curriculum vitae (cv)']:
                return Response({"detail": f"Invalid document type: {document_type}"}, status=status.HTTP_400_BAD_REQUEST)

            # Filter applications by tenant and branch
            if not applications_data:
                applications = JobApplication.active_objects.filter(
                    job_requisition_id=job_requisition_id,
                    tenant_id=tenant_id,
                    resume_status=True
                )
            else:
                application_ids = [app['application_id'] for app in applications_data]
                applications = JobApplication.active_objects.filter(
                    job_requisition_id=job_requisition_id,
                    tenant_id=tenant_id,
                    id__in=application_ids,
                    resume_status=True
                )

            logger.info(f"Screening {applications.count()} applications: {[str(app.id) for app in applications]}")
            if not applications.exists():
                logger.warning("No applications with resume_status=True found for provided IDs and filters.")
                return Response({"detail": "No applications with resumes found.", "documentType": document_type}, status=status.HTTP_400_BAD_REQUEST)

            if role == 'recruiter' and branch:
                applications = applications.filter(branch=branch)
            elif branch:
                applications = applications.filter(branch=branch)

            def download_resume(app, app_data, document_type_lower):
                try:
                    if app_data and 'file_url' in app_data:
                        file_url = app_data['file_url']
                    else:
                        cv_doc = next(
                            (doc for doc in app.documents if doc['document_type'].lower() == document_type_lower),
                            None
                        )
                        if not cv_doc:
                            app.screening_status = 'failed'
                            app.screening_score = 0.0
                            app.save()
                            return {
                                "app": app,
                                "success": False,
                                "error": f"No {document_type} document found",
                            }
                        file_url = cv_doc['file_url']

                    logger.info(f"About to download file for app {app.id}: {file_url}")
                    start_download = time.time()
                    headers = {"Authorization": f"Bearer {settings.SUPABASE_KEY}"}
                    try:
                        response = requests.get(file_url, headers=headers, timeout=10)
                    except requests.exceptions.Timeout:
                        app.screening_status = 'failed'
                        app.screening_score = 0.0
                        app.save()
                        return {
                            "app": app,
                            "success": False,
                            "error": f"Resume download timed out after 10 seconds for {file_url}",
                        }
                    except requests.exceptions.RequestException as e:
                        app.screening_status = 'failed'
                        app.screening_score = 0.0
                        app.save()
                        return {
                            "app": app,
                            "success": False,
                            "error": f"Resume download error: {str(e)}",
                        }
                    download_time = time.time() - start_download
                    file_size = len(response.content)
                    logger.info(f"Downloaded file for app {app.id} in {download_time:.2f}s, size: {file_size} bytes")
                    if response.status_code != 200:
                        app.screening_status = 'failed'
                        app.screening_score = 0.0
                        app.save()
                        return {
                            "app": app,
                            "success": False,
                            "error": f"Failed to download resume from {file_url}, status code: {response.status_code}",
                        }

                    content_type = response.headers.get('content-type', '')
                    file_ext = mimetypes.guess_extension(content_type) or os.path.splitext(file_url)[1] or '.pdf'
                    temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=file_ext)
                    temp_file.write(response.content)
                    temp_file.close()
                    temp_file_path = temp_file.name
                    logger.info(f"Finished download for app {app.id}")
                    return {
                        "app": app,
                        "success": True,
                        "temp_file_path": temp_file_path,
                        "file_url": file_url,
                    }
                except Exception as e:
                    logger.error(f"Download failed for app {app.id}: {str(e)}")
                    app.screening_status = 'failed'
                    app.screening_score = 0.0
                    app.save()
                    return {
                        "app": app,
                        "success": False,
                        "error": f"Download error for file: {str(e)}",
                    }

            # Step 1: Parallel download all files
            download_results = []
            applications_list = list(applications)
            applications_data_map = {str(a['application_id']): a for a in applications_data}
            with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
                future_to_app = {
                    executor.submit(
                        download_resume,
                        app,
                        applications_data_map.get(str(app.id)),
                        document_type_lower
                    ): app for app in applications_list
                }
                for future in concurrent.futures.as_completed(future_to_app):
                    result = future.result()
                    download_results.append(result)

            # Step 2: Parallel parse and screen only successfully downloaded files
            job_requirements = (
                (job_requisition.get('job_description') or '') + ' ' +
                (job_requisition.get('qualification_requirement') or '') + ' ' +
                (job_requisition.get('experience_requirement') or '') + ' ' +
                (job_requisition.get('knowledge_requirement') or '')
            ).strip()

            def parse_and_screen(result, job_requirements):
                app = result["app"]
                if not result["success"]:
                    # If the error is a timeout, return a specific message
                    error_msg = result["error"]
                    if "timed out" in error_msg.lower():
                        error_msg = f"Resume parsing or download timed out. Please try again or check the file."
                    return {
                        "application_id": str(app.id),
                        "full_name": app.full_name,
                        "email": app.email,
                        "error": error_msg,
                        "success": False
                    }
                temp_file_path = result["temp_file_path"]
                file_url = result.get("file_url", "")
                try:
                    logger.info(f"About to parse resume for app {app.id}")
                    start_parse = time.time()
                    resume_text = parse_resume(temp_file_path)
                    parse_time = time.time() - start_parse
                    logger.info(f"Finished parsing resume for app {app.id} in {parse_time:.2f}s")
                    logger.info(f"Extracted text length for app {app.id}: {len(resume_text) if resume_text else 0}")
                    logger.debug(f"Resume text sample for app {app.id}: {resume_text[:200] if resume_text else 'No text'}")
                    if temp_file_path and os.path.exists(temp_file_path):
                        os.unlink(temp_file_path)
                    if not resume_text:
                        app.screening_status = 'failed'
                        app.screening_score = 0.0
                        app.save()
                        return {
                            "application_id": str(app.id),
                            "full_name": app.full_name,
                            "email": app.email,
                            "error": f"Failed to parse resume for file: {file_url}",
                            "success": False
                        }
                    score = screen_resume(resume_text, job_requirements)
                    resume_data = extract_resume_fields(resume_text)
                    employment_gaps = resume_data.get("employment_gaps", [])
                    app.screening_status = 'processed'
                    app.screening_score = score
                    app.employment_gaps = employment_gaps
                    app.save()
                    return {
                        "application_id": str(app.id),
                        "full_name": app.full_name,
                        "email": app.email,
                        "score": score,
                        "screening_status": app.screening_status,
                        "employment_gaps": employment_gaps,
                        "success": True
                    }
                except Exception as e:
                    logger.error(f"Parsing failed for app {app.id}: {str(e)}")
                    app.screening_status = 'failed'
                    app.screening_score = 0.0
                    app.save()
                    if temp_file_path and os.path.exists(temp_file_path):
                        os.unlink(temp_file_path)
                    return {
                        "application_id": str(app.id),
                        "full_name": app.full_name,
                        "email": app.email,
                        "error": f"Screening error for file: {file_url} - {str(e)}",
                        "success": False
                    }

            results = []
            with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
                future_to_result = {
                    executor.submit(parse_and_screen, result, job_requirements): result for result in download_results
                }
                for future in concurrent.futures.as_completed(future_to_result):
                    results.append(future.result())

            # Separate successful and failed applications
            shortlisted = [r for r in results if r.get("success")]
            failed_applications = [r for r in results if not r.get("success")]

            if not shortlisted and failed_applications:
                return Response({
                    "detail": "All resume screenings failed.",
                    "failed_applications": failed_applications,
                    "document_type": document_type
                }, status=status.HTTP_400_BAD_REQUEST)

            shortlisted.sort(key=lambda x: x['score'], reverse=True)
            final_shortlisted = shortlisted[:num_candidates]
            shortlisted_ids = {item['application_id'] for item in final_shortlisted}

            for app in applications:
                app_id_str = str(app.id)
                if app_id_str in shortlisted_ids:
                    app.status = 'shortlisted'
                    app.save()
                    shortlisted_app = next((item for item in final_shortlisted if item['application_id'] == app_id_str), None)
                    if shortlisted_app:
                        shortlisted_app['job_requisition_id'] = job_requisition['id']
                        shortlisted_app['status'] = 'shortlisted'
                        employment_gaps = shortlisted_app.get('employment_gaps', [])
                        event_type = "job.application.shortlisted.gaps" if employment_gaps else "job.application.shortlisted"
                        send_screening_notification(
                            shortlisted_app,
                            tenant_id,
                            event_type=event_type,
                            employment_gaps=employment_gaps
                        )
                else:
                    app.status = 'rejected'
                    app.save()
                    rejected_app = {
                        "application_id": app_id_str,
                        "full_name": app.full_name,
                        "email": app.email,
                        "job_requisition_id": job_requisition['id'],
                        "status": "rejected",
                        "score": getattr(app, "screening_score", None)
                    }
                    send_screening_notification(rejected_app, tenant_id, event_type="job.application.rejected")

            return Response({
                "detail": f"Screened {len(shortlisted)} applications using '{document_type}', shortlisted {len(final_shortlisted)} candidates.",
                "shortlisted_candidates": final_shortlisted,
                "failed_applications": failed_applications,
                "number_of_candidates": num_candidates,
                "document_type": document_type
            }, status=status.HTTP_200_OK)

        except requests.exceptions.Timeout as e:
            logger.error(f"Gateway timeout during resume screening: {str(e)}")
            return Response({
                "error": "Resume screening timed out",
                "details": str(e),
                "suggestion": "The operation took too long to complete. Please try again later or reduce the number of applications."
            }, status=status.HTTP_504_GATEWAY_TIMEOUT)
        except requests.exceptions.ConnectionError as e:
            logger.error(f"Connection error during resume screening: {str(e)}")
            return Response({
                "error": "Unable to connect to resume screening service",
                "details": str(e),
                "suggestion": "Please check your network connection or contact support."
            }, status=status.HTTP_502_BAD_GATEWAY)
        except requests.exceptions.RequestException as e:
            logger.error(f"Gateway error during resume screening: {str(e)}")
            return Response({
                "error": "Resume screening gateway error",
                "details": str(e),
                "suggestion": "There was a network or service error. Please check your connection or contact support if the issue persists."
            }, status=status.HTTP_502_BAD_GATEWAY)
        except Exception as e:
            logger.exception(f"Error screening resumes for JobRequisition {job_requisition_id}: {str(e)}")
            return Response({
                "error": "Internal server error during resume screening",
                "details": str(e),
                "suggestion": "An unexpected error occurred. Please try again or contact support."
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


